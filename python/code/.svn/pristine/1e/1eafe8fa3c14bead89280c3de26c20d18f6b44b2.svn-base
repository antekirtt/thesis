#!/usr/bin/python

import socket
import optparse
import select
import sys
import Queue
import re, uuid
import struct
import os
import readline
import code
import atexit
from pprint import pprint

"""
class responsible for the physical communication
It gets the raw data from the simulated cable (udp) and send it to layer one
for processing.
It receives data from layer one and send it through the cable
"""
class ICMPv6:

    def __init__(self):
        self.localHost = ""
        #self.localPort = int(localPort)
        self.help = [70*'*','Help: \t\t\t=> Print this help', 'Connect: \t\t=> Connect to host, parameters are ip adr and port number', 'ChatName: \t\t=> Add/Change chat name', 'ListNames: \t\t=> List chat participants', 'ListRouting: \t\t=> List routing table', 'Neighbors: \t\t=> List neighbors table', 'Control: \t\t=> Swap activation control messages', 'Debug: \t\t\t=> Swap activation debug messages', 'Routing: \t\t=> Swap activation routing messages', 'Queues: \t\t=> Show packets number in queue (Sent and to Send)', 'Pub: \t\t\t=> Send public messgaes', 'Prv: \t\t\t=> Send private messages', 'Shell: \t\t\t=> Enter in Shell mode', 'Send: \t\t\t=> Send the preselected file, choosen with select in shell mode', 'Gpg: \t\t\t=> Enter in Gpg mode', 40*'*', 'Shell Mode Commands:', 'quit \t\t\t=> Quit shell mode', 'ls \t\t\t=> list file and directories', 'ls -l \t\t\t=> List files and directories extended format', 'cd \t\t\t=> Change directory', 'select \t\t\t=> Select file to send, argument is file name', 40*'*', 'Gpg Mode Commands:', 'quit \t\t\t=> Quit Gpg Mode', 'listKeys \t\t=> List public keys in keyring', 70*'*']
        self.commandBuffer = []

    def startupLogo(self):
        initLogo = [80*'*', '', '\t\t\tICMPv6 abusing - Prove of Concept', '', 80*'*']
        for line in initLogo:
            print line

    def showCursor(self):
        sys.stdout.write('[]>')
        sys.stdout.flush()

    def startSystem(self):
        self.inputs = [ sys.stdin ]
        self.startupLogo()
        self.showCursor()
        running = 1
        while running:
            readable,writable,exceptional = select.select(self.inputs,[],[], 1)
            for s in readable:
                if s == sys.stdin:
                    readline.parse_and_bind("tab: complete")
                    #we receive data from the keyboard                    
                    command  = raw_input(self.showCursor())
                    #get emtpy line
                    #if re.match(r'^\s*$', command):
                     #   self.showCursor()
                    #help command
                    if re.match("h", command):
                        self.showHelp()
                        self.showCursor()
                    #quit chat command
                    elif re.match("q", command):
                        running = 0
                        sys.exit(1)
                    #connect to host command
                    elif re.match("Connect:", command):
                        dest = re.sub("Connect:", "", command)
                        destIp = "".join(re.findall(r'[0-9]{1,3}(?:\.[0-9]+){3}', dest))
                        destPort =  "".join("".join(re.findall(r'[0-9]{1,5}(:[0-9]+)', dest)).split(':'))
                        try:
                            socket.inet_pton(socket.AF_INET, destIp)
                            if destPort != '' and len(destPort) <= 5:
                                Config.printC(destIp)
                                Config.printC(destPort)
                                self.layerOne.sendCON_REQ(destIp, destPort)
                        except socket.error:
                            print 'Socket error: invalid IP'
                    #shell mode command
                    elif re.match("Shell:", command):
                        shell = 1
                        while shell:
                            c = sys.stdin.readline()
                            if c == 'quit\n':
                                shell = 0
                                self.showCursor()
                            elif c == 'ls\n':
                                files = os.listdir('.')
                                for f in files:
                                    print f
                            elif c == 'ls -l\n':
                                files = os.system(c)
                                print files
                            elif re.match('cd', c):
                                path = re.sub('cd', ' ', c)
                                try:
                                    os.chdir(path.strip())
                                except:
                                    print 'Error! Wrong path!'
                            elif re.match('select', c):
                                path  = re.sub('select', ' ', c)
                                data = open(path.strip(), 'rb')
                                self.fileToSend = data.read()
                                data.close()
                                self.fileName = path.strip()
                            else:
                                print 'Error! Command not found!'
                    else:
                        print 'Error! Command not found!'
                        self.showCursor()
    
    def showHelp(self):
        for entry in self.help:
            print entry



class HistoryConsole(code.InteractiveConsole):
    def __init__(self, locals=None, filename="<console>",
                 histfile=os.path.expanduser("~/cyberSecurity/4sem/python/thesis/.console-history")):
        code.InteractiveConsole.__init__(self, locals, filename)
        self.init_history(histfile)

    def init_history(self, histfile):


        if hasattr(readline, "read_history_file"):
            try:
                readline.read_history_file(histfile)
            except IOError:
                pass
            atexit.register(self.save_history, histfile)

    def complete(text,state):
        results = histfile
        return results[state]
    
    readline.set_completer(complete)            

    def save_history(self, histfile):
        readline.set_history_length(100)
        readline.write_history_file(histfile)


def main():
    parser = optparse.OptionParser("usage: %prog")
    #parser.add_option('-p', dest='localPort', type='string', help='specify local port')
    (options, args) = parser.parse_args()
    #localPort = options.localPort
    #if(localPort == None):
     #   print parser.usage
     #   exit(0)
    icmpv6 = ICMPv6()
    history = HistoryConsole()
    icmpv6.startSystem()
    
if __name__ == '__main__':
	main()
