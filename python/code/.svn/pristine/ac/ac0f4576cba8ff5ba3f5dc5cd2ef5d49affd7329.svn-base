#!/usr/bin/python

import socket
import optparse
import select
import sys
import Queue
import re, uuid
import struct
import os
import readline
import code
import atexit
from pprint import pprint

"""
class responsible for framework initialization
it shows a command prompt, has tab completion and history of commands
"""
class ICMPv6:

    def __init__(self):
        self.localHost = ""
        #self.localPort = int(localPort)
        self.help = [70*'*','help \t\t\t=> Print this help', 'shell \t\t\t=> Enter in Shell mode', 'quit \t\t\t=> Quit framework', 40*'*', 'Shell Mode Commands:', 'quit \t\t\t=> Quit shell mode', 'ls \t\t\t=> list file and directories', 'ls -l \t\t\t=> List files and directories extended format', 'cd \t\t\t=> Change directory', 70*'*']
        self.commandBuffer = []

    #shows the logo of the framework
    def startupLogo(self):
        initLogo = [80*'*', '', '\t\t\tICMPv6 abusing - Proof of Concept', '', 80*'*']
        for line in initLogo:
            print line

    def showCursor(self):
        sys.stdout.write('[]>')
        sys.stdout.flush()

    #starts the interactive propmt
    def startSystem(self):
        self.inputs = [ sys.stdin ]
        self.startupLogo()
        self.setMainHistory()
        running = 1
        while running:
            readline.parse_and_bind("tab: complete")
            #we receive data from the keyboard                    
            command  = raw_input('[]>')
            #get emtpy line
            #if re.match(r'^\s*$', command):
            #   self.showCursor()
            #help command
            if re.match("help", command):
                self.showHelp()
            #quit framework command
            elif re.match("quit", command):
                running = 0
                sys.exit(1)
            #shell mode command
            elif re.match("shell", command):
                shell = 1
                self.setShellHistory()
                while shell:
                    c = raw_input('$')
                    if re.match("quit", c):
                        shell = 0
                        self.setMainHistory()
                    elif re.match(r'ls\s$', c):
                        files = os.listdir('.')
                        for f in files:
                            print f
                    elif re.match(r'ls -l', c):
                        files = os.system(c)
                        print files
                    elif re.match('cd', c):
                        path = re.sub('cd', ' ', c)
                        try:
                            os.chdir(path.strip())
                        except:
                            print 'Error! Wrong path!'

                    else:
                        print 'Error! Command not found!'
            else:
                print 'Error! Command not found!'
    
    def showHelp(self):
        for entry in self.help:
            print entry

    def setMainHistory(self):
        words = ['help', 'quit', 'shell']
        completer = HistoryConsole(words)
        readline.set_completer(completer.complete)                    

    def setShellHistory(self):
        shellWords = ['help', 'quit', 'cd', 'ls', 'ls -l']
        shellCompleter = HistoryConsole(shellWords)
        readline.set_completer(shellCompleter.complete)                    

"""
class representing the history of commands, either
main or shell commands
"""
class HistoryConsole:
    def __init__(self,history):
        self.history = history

    def complete(self,text,state):
        results =  [x+" " for x in self.history if x.startswith(text)]
        return results[state]


def main():
    parser = optparse.OptionParser("usage: %prog")
    #parser.add_option('-p', dest='localPort', type='string', help='specify local port')
    (options, args) = parser.parse_args()
    #localPort = options.localPort
    #if(localPort == None):
     #   print parser.usage
     #   exit(0)
    icmpv6 = ICMPv6()
    #history = HistoryConsole()
    icmpv6.startSystem()
    
if __name__ == '__main__':
	main()
