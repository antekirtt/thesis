
\documentclass[12pt]{article}     
\usepackage{graphicx}
\graphicspath{{figures/}}
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage[table,xcdraw]{xcolor}
\usepackage{todonotes}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage{tocloft}
\usepackage{amssymb}
%\renewcommand{\labelitemi}{\tiny$\blacksquare$} %For square itemized lists
\usepackage{caption} 
\captionsetup{labelsep=period}
\usepackage{verbatimbox} %To put program code in the center using Verbatim
\titlelabel{\thetitle.\quad}
\usepackage{times}
\usepackage{fancyhdr}
\setlength{\parindent}{0cm}
\usepackage{setspace}
%\linespread{1.3}
\setlength{\parskip}{1em}
\onehalfspacing
\usepackage{amsmath} 
\usepackage{amsthm}
% Packages for building tables and tabulars 
\usepackage{array}
\usepackage{tabu}   % Wide lines in tables
\usepackage{xspace} % Non-eatable spaces in macros
\usepackage[hypertexnames=false,colorlinks=true,linkcolor=blue]{hyperref}
\usepackage[all]{hypcap}
\usepackage{url}
% Packages for defining colourful text together with some colours
%\usepackage[table,xcdraw]{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{lightblue}{rgb}{0.95,0.97,1.0}
\definecolor{darkblue}{rgb}{0.90,0.92,1.0}
\usepackage{color}

% Standard package for drawing algorithms
% Since the thesis in article format we must define \chapter for
% the package algorithm2e (otherwise obscure errors occur) 
\let\chapter\section
\usepackage{algorithm2e}

% Macros that make sure that the math mode is set
\newcommand{\typeF}[1] {\ensuremath{\mathsf{type_{#1}}}\xspace}
\newcommand{\opDiv}{\ensuremath{\backslash \mathsf{div}}\xspace} 
\usepackage{listings}
\lstdefinestyle{bash}{
   language=bash,
   showspaces=false,
   showstringspaces=false,
   basicstyle=\ttfamily\scriptsize,
   columns=flexible,
   keywordstyle=\color{black},
   commentstyle=\color{black},
   breaklines=true
 }
 
\lstdefinestyle{python}{
   language=python,
   showspaces=false,
   showstringspaces=false,
   basicstyle=\ttfamily\scriptsize,
   columns=flexible,
   keywordstyle=\color{black},
   commentstyle=\color{blue},
   breaklines=true
 }

\usepackage{multirow}
\setlength{\tabcolsep}{0pt}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1-\arrayrulewidth\relax}}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1-\arrayrulewidth\relax}}

\usepackage{booktabs}
\usepackage{tikz}
%used for ex. for m prime
\usepackage{flexisym}
\usepackage{footnote}

\usepackage{arydshln}
\usepackage{placeins}
\usepackage{enumitem}
\usepackage{cleveref}
\crefformat{footnote}{#2\footnotemark[#1]#3}
\crefname{table}{tab.}{tabs.}
\crefname{section}{chap.}{chaps.}
\usepackage{IEEEtrantools}

\begin{document}
\bstctlcite{IEEEexample:BSTcontrol}
%------------------------------TIITELLEHT---------------------------------
\thispagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\headheight = 57pt
\footskip = 11pt
\headsep = 0pt

\chead{
 \textsc{\begin{Large} %Tekst suurtähtedega ja suuremaks
	Tallinn University of Technology\\
	\end{Large} }
	Department of Computer Science\\	
	TUT Centre for Digital Forensics and Cyber Security
}
\vspace*{7 cm}

\begin{center}
ITC70LT\\[0cm]

Christian Ponti 144704\\
\vspace{15pt}
\begin{LARGE}
\textsc{Use of ICMPv6 in a scenario-based experiment for computer network exfiltration and infiltration operations\\}
\end{LARGE}
\vspace{10pt}
Master Thesis\\[2cm]
\end{center}

\begin{flushright}
Supervisor: Bernhards Blumbergs\\[0cm]
MsC\\[0cm]
\end{flushright}

\cfoot{Tallinn 2016} 
\pagebreak

%---------------------------AUTORIDEKLARATSIOON-------------------------
\section*{\begin{center}
 Autorideklaratsioon
\end{center}}


Autorideklaratsioon on iga lõputöö kohustuslik osa, mis järgneb tiitellehele.
Autorideklaratsioon esitatakse järgmise tekstina:

Olen koostanud antud töö iseseisvalt. Kõik töö koostamisel kasutatud teiste autorite tööd, olulised seisukohad, kirjandusallikatest ja mujalt pärinevad andmed on viidatud. Käsolevat tööd ei ole varem esitatud kaitsmisele kusagil mujal.

Autor: [Ees$-$ ja perenimi]

[\today]
\pagebreak

%---------------------------ANNOTATION---------------------------------
\section*{\begin{center}
Annotatsioon
\end{center}}

Annotatsioon on lõputöö kohustuslik osa, mis annab lugejale ülevaate töö eesmärkidest, olulisematest käsitletud probleemidest ning tähtsamatest tulemustest ja järeldustest. Annotatsioon on töö lühitutvustus, mis ei selgita ega põhjenda midagi, küll aga kajastab piisavalt töö sisu. Inglisekeelset annotatsiooni nimetatakse Abstract, venekeelset aga


Sõltuvalt töö põhikeelest, esitatakse töös järgmised annotatsioonid:
\begin{itemize}
\item kui töö põhikeel on eesti keel, siis esitatakse annotatsioon eesti keeles mahuga $\frac{1}{2	}$ A4 lehekülge ja annotatsioon \textit{Abstract} inglise keeles mahuga vähemalt 1 A4 lehekülg;
\item kui töö põhikeel on inglise keel, siis esitatakse annotatsioon (Abstract)  inglise keeles mahuga $\frac{1}{2}$ A4 lehekülge ja annotatsioon eesti keeles mahuga vähemalt 1 A4 lehekülg;
\end{itemize}

Annotatsiooni viimane lõik on kohustuslik ja omab järgmist sõnastust:

Lõputöö on kirjutatud [mis keeles] keeles ning sisaldab teksti [lehekülgede arv] leheküljel, [peatükkide arv] peatükki, [jooniste arv] joonist, [tabelite arv] tabelit.
\pagebreak


%-----------------------------ABSTRACT-----------------------------------

\section*{\begin{center}
Abstract
\end{center}}

\textit{The ICMPv6 protocol assumes new relevance for the correct operations of IPv6, with respect to the ICMP protocol. In fact, even if they share the same naming convention and some functionalities, they are two different protocols. In terms of security, the configuration of the firewalls, the border network devices to which part of the security is delegated, is critical. The ICMPv6 protocol requires to follow new best practices in the configuration of the firewalls, because old practices are no more applicable. This point is crucial, because taking into account the cohexistence of IPv4 and IPv6 during the transition period, the risk is to apply old practices also for ICMPv6, in environments where IPv6 is active by default in most OSs.\\
The ICMPv6 specifications, described by RFCs, are the starting point to understand the functionalities of the protocol. Since RFCs represent an agreement between different stakeholders, it is necessary and urgent to verify its implementation inside end-systems. This verification should also include an environment with a border network device. This allows to both assess the implementation of the protocol, and to define new best practices for the firewall.\\
A scenario-based experiment, where each scenario represents a firewall configuration, is the ideal candidate. In addition, experimentation must consider the two network flow directions, one originating from an external network, and one originating from the internal local segment. Particular attention must be payed for the latter, because  }

\pagebreak

%---------------------Glossary of terms and Abbreviations---------------------

\section*{\begin{center}
Glossary of Terms and Abbreviations
\end{center}}

\begin{tabular}{L{3.3cm}L{12cm}}
\hdashline
\textit{Node}:&a device that implements IPv6\cite{rfc4861}.\\
\hdashline
\textit{Link}:&a communication facility or medium over which nodes can communicate at the link layer, i.e., the layer immediately below IPv6\cite{rfc4861}.\\
\hdashline
\textit{Interface}:&a node's attachment to a link\cite{rfc4861}.\\
\hdashline
\textit{Neighbors}:&nodes attached to the same link\cite{rfc4861}.\\
\hdashline
\textit{Prefix}:&a bit string that consists of some number of initial bits of an address\cite{rfc4861}.\\
\hdashline
\textit{On-link}:&an address that is assigned to an interface on a specified link\cite{rfc4861}.\\
\hdashline
\textit{Off-link}:&an address that is not assigned to any interfaces on the specified link\cite{rfc4861}.\\
\hdashline
\textit{Longest prefix match}:&the process of determining which prefix in a set of prefixes covers a target address. A target address is covered by a prefix if all of the bits in the prefix match the left-most bits of the target address. When multiple prefixes cover an address, the longest prefix is the one that matches\cite{rfc4861}.\\
\hdashline
\textit{Reachability}:&whether or not the one-way "forward" path to a neighbor is functioning properly. In particular, whether packets sent to a neighbor are reaching the IP layer on the neighboring machine and are being processed properly by the receiving IP layer\cite{rfc4861}.\\
\hdashline
\textit{Packet}:&an IPv6 header plus payload\cite{rfc4861}.\\
\hdashline
\textit{Link MTU}:&the maximum transmission unit, i.e., maximum packet size in octets, that can be conveyed over a link\cite{rfc4861}.\\
\hdashline
\textit{Path MTU}:&the minimum link MTU of all the links in a path between a source node and a destination node\cite{rfc4861}.\\
\hdashline
\textit{Multicast capable}:&a link that supports a native mechanism at the link layer for sending packets to all (i.e., broadcast) or a subset of all neighbors\cite{rfc4861}.\\
\hdashline
\textit{Point-to-point}:&a link that connects exactly two interfaces\cite{rfc4861}.\\
\hdashline
\end{tabular}

\begin{savenotes}
\begin{tabular}{L{3.3cm}L{12cm}}
\hdashline
\textit{Link-local address}:&a unicast address having link-only scope that can be used to reach neighbors\cite{rfc4861}.\\
\hdashline
\textit{All-nodes multicast address}:&the link-local scope address to reach all nodes, FF02::1\cite{rfc4861}.\\
\hdashline
\textit{All-routers multicast address}:&the link-local scope address to reach all routers, FF02::2\cite{rfc4861}.\\
\hdashline
\textit{Solicited-node multicast address}:&a link-local scope multicast address that is computed as a function of the solicited target's address. The function is chosen so that IP addresses that differ only in the most significant bits will map to the same solicited-node address thereby reducing the number of multicast addresses a node must join at the link layer\cite{rfc4861}.\\
\hdashline
\textit{Unspecified address}:&a reserved address value that indicates the lack of an address. It is never used as a destination address, but may be used as a source address if the sender does not know its own address. The 
unspecified address has a value of 0:0:0:0:0:0:0:0\cite{rfc4861}.\\
\hdashline
\textit{Covert Channel}:&is a communication paths that allow information transfer in violation of a system’s security policies. In the context of network protocols, covert channel communication is generally achieved by manipulating an overt communication\cite{lewandowski} \footnote{open to view or knowledge; not concealed or secret, \url{http://www.dictionary.com/browse/overt}, accessed 1.4.2016}.\\
\hdashline
\textit{Cover traffic}:&is the traffic that is being manipulated by covert channel participants\cite{lewandowski}.\\
\hdashline
\textit{Storage Covert Channel}:&manipulates a storage location in such a way that it conveys information to an observer. This definition was initially applied only to covert channels within a single machine or at least with a shared storage location. It was then extended to network covert channels and in this context, a storage channel is understood to be a channel that relies on modification of network traffic content\cite{lewandowski}.\\
\hdashline
\textit{Active Warden}:&is positioned so that it can observe and modify network traffic in its area of responsibility. The task of active wardens is to prevent and disrupt covert channel communication by modifying the content of network traffic\cite{lewandowski}\\
\hdashline
\end{tabular}
\end{savenotes}

\begin{savenotes}
\begin{tabular}{L{3.3cm}L{12cm}}
\hdashline
\textit{Policy}:&a formal, brief, and high-level statement or plan that embraces an organization's general beliefs, goals, objectives, and acceptable procedures for a specified subject area \footnote{\label{policy}\url{http://www.slu.edu/its/policies-and-processes}, accessed 1.4.2016}.\\
\hdashline
\textit{Standard}:&a mandatory action or rule designed to support and conform to a policy \cref{policy}.\\
\hdashline
\textit{Procedure}:&procedures describe the process: who does what, when they do it, and under what criteria \cref{policy}.\\
\hdashline
\textit{System Preservation}:&guarantees that the stegomessage is well formed within the rules of the protocol; the actual meaning of the stegomessage may be different than the original cover\cite{lucena2}.\\
\hdashline
\textit{Semantic Preservation}:&means that, as observed at a point along the message’s path through the network, the stegomessage has the same meaning as the original cover\cite{lucena2}.\\
\hdashline
\textit{IDS}:&Intrusion Detection System.\\
\hdashline
\textit{IPS}:&Intrusion Prevention System.\\
\end{tabular}
\end{savenotes}



\pagebreak

\tableofcontents
\newpage
\listoffigures
\pagebreak
\listoftables
\pagebreak

\section{Introduction}
\label{sec:1}


IPv6 is the designated successor of IPv4, a protocol specified and implemented in a context with a limited number of users and hosts, most of them circumscribed to the scientific world. The need of a new protocol arose because of a changed context: the evolution of new powerful devices and their spread in many field of the society, which in turn modified the behavior and the requests of new entities, being them individuals or big organizations. The new IP protocol has been specified and redesigned in many aspects, taking into consideration the evolution of the requirements and the future needs of the involved actors.

IPv6, with respect to his predecessor, changed in many aspects. The headers have been modified to accommodate new functionality and improved capabilities, mainly it provides ``expanded addressing capabilities'', ``header format simplification'', ``improved support for extensions and options'', ``flow labeling capability'', and ``authentication and privacy capabilities''. One of the most relevant aspect is the increased address space from 32 to 128 bits, which deals with the demand of new communicating devices to fulfill organization's requirements.\cite{rfc2460}

Despite IPv6 specifications have been formalized in 1998, its spread and adoption by the world community is far from being accomplished. Among the many possible reasons that could explain this behavior, two of them deserve particular attention. The first one is the depletion of address space, which has been mitigated by the introduction of Network Address Translation (NAT)\cite{rfc3022}: the use of NAT allows to use a private, not routeable, address space for the internal network of an organization, and the use of one, or limited number, public IPv4 address at the network boundary. This technique mitigated the need to request an IPv6 128 bits address by organizations, because their requirements to allocate new IPv4 address from IANA\footnote{\url{http://www.iana.org/}, accessed 20.03.2016} have been reduced. The second reason is related to the applications and services offered by organizations. These applications have been written for, and tested against, IPv4. Many of them represents IT assets which are critical for the business assets of enterprises: the introduction of new applications written for IPv6 represents a great effort in terms of financial investment, time for implementation and testing, and use of enterprises' resources.

The IPv6 world is composed by a number of protocols, which are used by nodes to fulfill their requirements: for some of them it is possible to find similar functionality in IPv4, while others are completely new protocols. In this set of protocols, one of them deserves particular attention: ICMPv6.

ICMPv6, despite it shares almost the same naming convention with respect with the predecessor, it is a new protocol, which make it a critical subject of research by the scientific community. The reasons behind its criticality arise because it holds some functions which are similar in ICMP (e.g. Echo Request), but at the same time it introduces a number of new functionalities, and responsibilities, for the correct behavior of an IPv6 node.

ICMP has been used by IPv4 to manage Error and Informational messages to allow for a better management and troubleshooting of the network.  This protocol has been tested for many years, with the identification of vulnerabilities which can potentially be exploited by malicious actors. Many best practices \footnote{\url{http://www.cisco.com/c/en/us/support/docs/ip/access-lists/13608-21.html\#anc29}, accessed 20.03.2016} \footnote{\url{http://www.cisco.com/c/en/us/about/security-center/firewall-best-practices.html\#\_Toc332805964}, accessed 20.03.2016} suggested to filter ICMP messages at network boundaries to mitigate the risk of the exploitation of some vulnerabilities without compromising the network functionalities. Nowadays the network evolved in more sophisticated designs, and new concepts, like Bring Your Own Device (BYOD) and wireless networks, partially obsolete the very same concept of boundaries, bringing new threats to the internal network. The security controls could no more be applied only at the boundaries, but must be introduced in other segments of the network. This new security controls applies to the ICMP protocol as well, and filtering must be introduced where such messages are not strictly required by network administrators.

``ICMPv6 is used by IPv6 nodes to report errors encountered in processing packets, and to perform other internet-layer functions, such as diagnostics (ICMPv6 Echo). ICMPv6 is an integral part of IPv6, and the base protocol (all the messages and behavior required by this specification) MUST be fully implemented by every IPv6 node''\cite{rfc4443}.

This paragraph from RFC 4443 describes broadly the purpose of ICMPv6, but an important part is underlined by the last sentence, which states that the base protocol must be fully implemented by every IPv6 node. In the RFC terminology, the word “MUST, or the terms REQUIRED or SHALL, mean that the definition is an absolute requirement of the specification“\cite{rfc2119}. The real distinction between ICMP and ICMPv6 in this context is formal: RFC 792 states that ``ICMP [...] must be implemented by every IP module''\cite{rfc792}, which means that an implementation is required. The ICMPv6 specification is more precise because it refers to every IPv6 node, which covers the implementation inside the module, but also, with the concept of node, implies that the node must be able to use its functions.

This is a fundamental distinction, because the best practices in use with ICMP, with ICMPv6 are no more relevant, at least with some message types. As it is written in this paper\cite{chak}, which cites RFC 4861\cite{rfc4861}, ``ICMPv6 is used for basic functionalities and used by other IPv6 protocols [...] Neighbor Discovery Protocol is a protocol used with IPv6 to perform various tasks like router discovery, stateless automatic address configuration of a node, neighbor discovery, duplicate address detection, determining the Link Layer addresses of other nodes, address prefix discovery, and maintaining routing information about the paths to other active neighbor nodes''.

This is the first critical point to consider: despite version 4 and version 6 of the ICMP protocol have some similar functions, they are different protocols. ICMPv6 is not a protocol modified to adapt itself to IPv6, a new analysis must be performed in an exhaustive way taking into account new scenarios, and new best practices must be applied to mitigate the risk of exploitation of new vulnerabilities related to its functionalities.

Another important aspect to take into consideration when dealing with IPv6 in general, and with ICMPv6, is the transition from version 4 to version 6. For the aforementioned reasons, many organizations delayed as much as they could the deployment of an IPv6 native Internet connectivity. Nevertheless the scientific community continued to improve the new version and its related protocols, and Operating Systems (OS) started to include them in their network implementations. At the same time, techniques to allow a slow transition have been developed: examples of that are the dual stack, the presence and coexistence of both protocol versions in the same node, or the encapsulation of IPv6 inside IPv4, in those network segments where IPv6 has not been deployed yet. Additionally, in many OS, IPv6 is active by default and preferred over IPv4.

These aspects must not be underestimated and show again how critical and urgent is an in-depth analysis of ICMPv6: not only this protocol is fundamental for IPv6 and the best practices can be used only against the previous version, but it is already present and activated in OSs that users employ in their everyday life. The last statement introduces another aspect to take into account: network administrator and security officer must not deal only with threats deriving from the exploitation of technical vulnerabilities, but also with behavioral procedures shaped around years of practice. IPv6 and ICMPv6 are not protocols that will be introduced in the future, they are already present in this transition period and we must deal with them now. Countermeasures must be in place, at the network boundaries and inside critical network segments above all, that take into consideration version 6 of the protocols. Such countermeasures must follow new best practices carefully shaped around the new version.

The underlined elements, the differences between the two ICMP versions and the transition period with the coexistence of IPv4 and IPv6, lead to another topic: the impact of the full deployment of IPv6, and ICMPv6, and the implications for the involved actors, being them users, enterprises, states, or malicious actors.

The scientific community has been involved in the specification, in the improvement, and testing of the protocols since time. But, with respect with the preceding version of the protocols, version 6 of the suite must deal with a different situation. The electronic communication is spread around the world in a pervasive way, and the near future, with the Internet of Things (IoT) \footnote{IoT, \url{http://www.theinternetofthings.eu/what-is-the-internet-of-things}, accessed 21.03.2016}, will further the spread. ICMPv6, and IPv6, will be fully deployed in a world strongly dependent on the electronic communication, where critical infrastructures (CI) must be managed and protected, where enterprises relies on its IT infrastructure to support their business assets, and where users are tight to their online experience for their everyday needs. This change in the very basic infrastructure of the network will have an impact which has no terms of comparison with respect to IPv4, where the initial small amount of users allowed to discover the concept of security and to learn by experience. The transition period, which introduced some security issues, in this case works as a mitigation technique to allow researcher to test the protocols in an exhaustive way, without waiting that the fully deployed IPv6 infrastructures reveals potential weaknesses.

This urgency can be better understood by taking into consideration the evolution of the threats, the sophistication of malware, and the malicious actors involved in the research of vulnerabilities to exploit, as well as their purposes and means to reach their goals.

The term Advanced Persistent Threat (APT) is used to define ''any sophisticated adversary engaged in information warfare in support of long-term strategic goals``\cite{apt}. One of the main characteristic of APT detected in the wild is the sophistication of the attack. One example is the Uroburos rootkit\cite{uroburos}, which ''modular structure allows extending it with new features easily, which makes it not only highly sophisticated but also highly flexible and dangerous``. The analysis of the rootkit suggests that ''the development of a framework like Uroburos is a huge investment`` and ''that it was designed to target government institutions, research institutions or companies dealing with sensitive information as well as similar high-profile targets``. There are other example of APT that suggested an evolution of the threat landscape, like Stuxnet\cite{stuxnet}. Even if the aforementioned malware do not target directly IPv6, they share a common characteristic which is important to underline: the sophistication, the investment behind them, and the presence of an Advanced Persistent Adversary (APA), term that ''depicts not only the threat, but the threat actors as well``\cite{apa}.

The evolution of the threat landscape depicts a situation where APA, often associated with groups sponsored by state actors, have a remarkable budget to develop very sophisticated attacks to reach their goals. In the current situation, given the impact that the full deployment of IPv6 will have, those actors have the resources and the motivation to research and discover vulnerabilities in IPv6, ICMPv6, and other protocols involved. 
Moreover, if this research will succeed, APA can gain a considerable advantage over their opponents, because a possible vulnerability at network layer may allow to bypass more easily the security mechanisms in place and give more robust mechanisms to stay undetected for longer.

While research and tests on ICMPv6 are an ongoing process, the urgency and criticality of the subject require a more in-depth analysis which take into account the full deployment, but also the transition period. To pursue this goal it is important to start from the specifications of the protocol, the RFCs. Those documents represent a guideline, the result of an agreement between many stakeholders. As a guideline, there is no guarantee that the implementation will follow the suggestion, even in the sections specified with a must.

The first contribution of this research is to produce the necessary awareness with regard to IPv6 and ICMPv6. This is the starting point to understand the need to analyze the protocols in detail. Furthermore, it is important to see the big picture, which include not only ICMPv6, but also its relationship with the devices involved in the communication. Firewalls are devices configured by human beings, which may commit mistakes and use different best practices. Each configuration can produce a different scenario, which is worth to analyze because in the real world each system may differ from another, and the goal of an APA is to find these slight differences between them to take advantage. This work's contribution is an analysis of different scenarios where the use of the ICMPv6 protocol could arise different security issues, with respect to the configuration of network boundary devices. A scenario-based experiment needs also a test set, based on RFC specifications, and the implementation of a software to conduct the experiments, which also represent a contribution of this research that other researchers can use to validate the experiment, or can modify to their needs to include other scenarios and tests.

Since best practices must be applied, this research will contribute by providing a firewall configuration based on them. This configuration is part of a scenario and will be used as a starting point to discuss the state of ICMPv6, in terms of security. In addition, the comparison with another configuration/scenario, where the firewall's task is just to forward packets, will show how much the protocol needs to rely in other services to provide security. This contribution will also offer a point of view, based on the network flow direction, to understand the relevance of the firewall, and its rules, in providing the necessary security to an organization's network. This point of view involves also the design of the protocol and its ability to provide some level of security in a particular scenario and network direction flow, which, in turn, modifies the relevance of the firewall.

The novelty of this research resides in the scenario-based experiment, which involves the identification of a test set based on the RFCs specifications, to find possible vulnerabilities that can be exploited. Furthermore, the tests must consider both directions of the network flow, from the outside to the internal network, and from the internal and trusted network to the outside. The traffic traveling in both directions must cross a network boundary device, which is a necessary condition to consider a potential vulnerability as such. The reason behind the novelty of this approach is that, as this research will underline in next chapters, other researches consider only one traffic flow direction, or the compliance with the protocol itself of most implementation, without considering network boundary devices, which, taking into account the transition period, may or may not be configured to cope with IPv6 and the related protocols. Furthermore, this research is developed from a penetration testing point of view. Penetration testing is a process with the aim to gain access to resources with the permission of the owner\cite{penTesting}. This point of view is important, because the process simulates what an attacker may do while attempting to gain access to company resources. As the research will point out, a vulnerability may exist, but its exploitation may depend on the configuration of a firewall, which might reduce the probability of the exploitation by a malicious actor.

The next chapters of this work will explore the background, the specifications inside RFCs, and the related work (see~\cref{sec:2}), which includes existing tools and projects to test ICMPv6, and a review of the literature. Then the analysis proceeds with the definition of the methodology (see~\cref{sec:3}) of this research, which is based on the scientific method of the experimentation; the chapter includes the motivation behind this choice and behind the choice of the technology to conduct the experiments. The implementation is the next chapter (see~\cref{sec:4}), which deals with the details of the technology, followed by the experiment (see~\cref{sec:5}), which describes the set of performed tests. The chapter related to the results (see~\cref{sec:6}) includes a discussion about the results of the experiment and its meaning. Finally, the conclusions (see~\cref{sec:7}) summarizes the research, discuss about suggestions and future work.

 

\pagebreak
%------------------------------BACKGROUND AND RELATED WORK-----------------------------------
\section{Background and Related Work}
\label{sec:2}


\subsection{Background}
\label{sub:background}

``The Internet Standards process is an activity of the Internet Society\footnote{\url{http://www.internetsociety.org/}, accessed on 25.03.2016} that is organized and managed on behalf of the Internet community by the Internet Architecture Board (IAB)\footnote{\url{https://www.iab.org/}, accessed on 25.03.2016} and the Internet Engineering Steering Group (IESG)\footnote{\url{https://www.ietf.org/iesg/}, accessed on 25.03.2016}. [...] an Internet Standard is a specification that is stable and well-understood, is technically competent, has multiple, independent, and interoperable implementations with substantial operational experience, enjoys significant public support, and is recognizably useful in some or all parts of the Internet. [...] Each distinct version of an Internet standards-related specification is published as part of the Request for Comments (RFC) document series.  This archival series is the official publication channel for Internet standards documents and other publications of the IESG, IAB, and Internet community.''\cite{rfc2026}

This work starts by analyzing the RFCs related to ICMPv6, which specify the protocol and the features to which each implementation must adhere. The main goal of an agreement on a protocol is interoperability \footnote{\url{http://www.merriam-webster.com/dictionary/interoperability}, accessed on 25.03.2016}, but, since this is not a binding process, and even though implementations follow the main specifications, it is always possible that some of them do not adhere completely. This could lead to some interoperability issues, which may introduce vulnerabilities in the protocol.

The background of this research is represented by two RFCs, ``Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification''\cite{rfc4443}, and ``Neighbor Discovery for IP version 6 (IPv6)''\cite{rfc4861}. These two RFCs specify the general header for ICMPv6 messages, and each specific message header to which each implementation must adhere.

The mentioned RFCs represents the core of this research. Nevertheless, there are other RFCs that it is worth to briefly introduce inside this chapter. The reason behind this choice is the dependency between different RFCs: some concepts or definitions that the core RFCs cite are developed inside other RFCs, while other RFCs introduce new fields, which are not yet accepted by the community, but are implemented in some development libraries used for this research. These RFCs are only partially in scope with this research.

The IPv6 specification\cite{rfc2460} is only partially in the scope of this research, but it must be mentioned, because of its tight relationship with ICMPv6, and because in each ICMPv6 message type specification some of its fields are cited. Other RFCs used by the research are the ``Extended ICMP to Support Multi-Part Messages''\cite{rfc4884}, and the RFCs that specifies additional Flags for the Router Advertisement message \cite{rfc3775}\cite{rfc4191}\cite{rfc4389}. These RFCs are not in scope with these research, even though the flags that they specify will determine some of the choices of this research, as it will underlined later.

RFCs use a specific set of words to express the requirements of the implementations \cite{rfc2119}. Words like ``must'', or ``should'' have a particular meaning, as expressed in the cited document, that should be well understood by implementors. The reason is that a lack of compliance may lead to the introduction of some vulnerabilities, where a node is expecting a particular behavior from another peer, while the peer's implementation follows slightly different specifications. This research will use these key words to generate some tests, inside the second part of the research, to verify the enforcement of the rules associated to them.

\textbf{RFC 2460}

From the point of view of this research, there are four interesting fields which are strictly involved in the ICMPv6 specification~\cite{rfc2460}:
\vspace{-10pt}
\begin{itemize}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Next Header:\quad identifies the type of header immediately following the IPv6 header. The ICMPv6 value is 58. The complete list is available on IANA's website\footnote{\url{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}, accessed on 27.03.2016}
 \item Hop Limit:\quad decremented by 1 by each node that forwards the packet.
 \item Source Address
 \item Destination Address
\end{itemize}

While the Destination Address must be used to route the packets to the destination, the Source Address can be manipulated by an attacker. This is often referred to as spoofing the source address. The goal for an attacker is to hide and represent itself as a legitimate source.

The Hop Limit is another field extensively used inside the specifications of the messages defined by the Neighbor Discovery protocol. The value of 255 is required to enforce the local segment scope of the protocol.

\textbf{RFC 4443}

ICMPv6 messages are categorized by its type field, while the code field in this specification identifies a specific message under the category.

The Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification categorizes two broad type of messages, Error and Informational messages. The tables (see~\cref{table:ICMPv6ErrorMessages} and~\cref{table:ICMPv6InformationalMessages}) summarize the type of ICMPv6 messages described in this RFC.

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{3pt}
\begin{tabular}{|L{3.0cm}|L{8.0cm}|}
\rowcolor{lightblue}
\hline
Type field&Error Message\\
\hline
1&Destination Unreachable\\
\hline
2&Packet Too Big\\
\hline
3&Time Exceeded \\
\hline
4&Parameter Problem\\
\hline
\end{tabular}
\caption{ICMPv6 Error Messages}
\label{table:ICMPv6ErrorMessages}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{3pt}
\begin{tabular}{|L{3.0cm}|L{8.0cm}|}
\rowcolor{lightblue}
\hline
Type field&Informational Message\\
\hline
128&Echo Request\\
\hline
129&Echo Reply\\
\hline
\end{tabular}
\caption{ICMPv6 Informational Messages}
\label{table:ICMPv6InformationalMessages}
\end{table}
\end{savenotes}
Besides type and code fields, another field is common to all the ICMPv6 messages: the checksum. The checksum is ``used to detect data corruption in the ICMPv6 message and parts of the IPv6 header'' and ``is the 16-bit one's complement of the one's complement sum of the entire ICMPv6 message, starting with the ICMPv6 message type field, and prepended with a pseudo-header of IPv6 header fields''. The procedure implies to sum up the binary values of 16 bit at a time, and invert the bit values of the final result.\cite{rfc2460}

The RFC includes a Message Processing Rules section, which underlines the rules that a node must observe while processing an ICMPv6 message. This section contains rules that must be enforced by each implementation, and will be used to build some of the test of the second part of this research.

As this research will show, some test may be spread across different scenarios, while other are more suitable to be performed only in a specific scenario. An example of that is an Echo Request message, which will be used to test the message itself, but it is also part of other tests, as payload, or to activate some process inside the target in the context of the Neighbor Discovery protocol (see~\cite{rfc4861}).

Attacks against this kind of messages include network scanning, Neighbor Cache exhaustion, and the fragmentation of the packets. Even if some of them are more difficult to perform, comparing to its IPv4 version, they are still present. The complete scan of an IPv6 network using an Echo Request, for example, is not feasible, even though it is possible to achieve in a more selective way, but a slightly modified packet, with a spoofed source address which prefix is equal to one of the internal segment, can produce side effects like the Neighbor Cache exhaustion of the target host\cite{schaefer}.


\textbf{RFC 4861}
\label{subsub:4861}

The Neighbor Discovery (ND) protocol has many functionalities. It is used by an IPv6 node to discover routers, to learn about parameters for the comunication inside and outside the network segment, to obtain or give information about the addressing scheme, to determine the link-layer address of neighbors, hosts and routers. In addition, it is used for the reachability process, to determine if a host is still alive, and to determine if an address is already in use by another node on the link.

The RFC defines five additional messages, characterized by the type field (for these messages the code is always zero), as summarized in \cref{table:4861Messages}.

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{3pt}
\begin{tabular}{|C{3.0cm}|L{8.0cm}|}
\rowcolor{lightblue}
\hline
Type field&Message\\
\hline
133&Router Solicitation\\
\hline
134&Router Advertisement\\
\hline
135&Neighbor Solicitation\\
\hline
136&Neighbor Advertisement\\
\hline
137&Redirect\\
\hline
\end{tabular}
\caption{RFC 4861 Messages}
\label{table:4861Messages}
\end{table}
\end{savenotes}

This RFC defines in addition five options, with the possibility to be extended in the future, that ``provide a mechanism for encoding variable length fields, fields that may appear multiple times in the same packet, or information that may not appear in all packets''\cite{rfc4861}. Options defined in the document are:
\vspace{-10pt}
\begin{itemize}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Source Link-Layer Address
 \item Target Link-Layer Address
 \item Prefix Information
 \item Redirect Header
 \item MTU
\end{itemize}
For each message type, one or more options are allowed, or required, to include the necessary information to perform the tasks for which it has been sent.

The RFC specifies the tasks for which a message has been defined, and the entities that are allowed to send them, or the node type that should expect such a message. Another information regards the scope of the message, which is link-local. That is, the network segments which boundaries are defined by a layer three device that is able to forward the packets to other network segments. This information is important, because some rules enphasize and enforce this concept, by the definition of field values that deny the forward of a packet (e.g. the IPv6 Hop Limit field must be 255), or by the definition of the scope of the address that must be used in the source and destination address fields (e.g. an address with link-local scope). The processing rules section, of each message type, defines some of these rules, by stating the requirements that a packet must satisfy in order to be accepted by the node.

The Neighbor Discovery protocol has been discussed mostly regarding internal attacks, in scenarios characterized by insiders, disgruntled employees, or attackers that gained a foothold in the internal network. Such attacks include the Denial of Service (DOS), for example by preventing new nodes to configure their IPv6 address, and Man in the middle (Mitm), where the attacker positions itself between a target and the boundary device to manipulate or intercept the network traffic. Other attacks include the manipulation of packets usually sent by a router (Router Advertisement) in order to manipulate the creation of IPv6 addresses, or the modification of information such as the Maximum Transmission Unit (MTU) of the link. One aspect to take into consideration is the complexity of ICMPv6 and their specifications. RFCs are developed to add new functionalities, to modify obsolete functions, or add new message types. Inside this galaxy of documents, vulnerabilies may be introduced in the implementation of the protocol\cite{schaefer}.

This research, during experimentation, will try to abuse the ND protocol from the outside network to verify the implementation of the rules that define its link local scope.

\textbf{RFC 4884}

This proposed standard specifies additional fields for both ICMP and ICMPv6. There are two ICMPv6 message types that are involved in this specification, Destination Unreachable and Time Exceeded. For both of them, a Length field has been added in the most significant bit space that was reserved for the Unused field. Accordingly to the RFC, ``the syntax and semantics of all fields are unchanged''\cite{rfc4884}.

\textbf{RFC 3775, RFC 4191, RFC 4389}

These RFCs specifies flags added to the Router Advertisement message, and are not in scope with this research. Despite this, as for RFC 4884, one library used to build the experiment implements this proposed change, and should be taken into account.\cite{rfc3775,rfc4191,rfc4389}

Another reason to briefly cite these RFCs is to show the complexity of the implementation of the ICMPv6 protocol. Even though an implementation must strictly adhere to the accepted RFCs, there are situations where the new functionalities are included, like a testing library, or a new application under testing that will include such functions. The complexity, both on following the requirements inside the galaxy of RFCs, and because ICMPv6 messages are used by other protocols and functionalities, may introduce vulnerabilities that are more difficult to discover.

In order to promote the use of IPv6 and to assess the readiness of applications and OSs, a project called IPv6 Ready has been created, and it is dicussed next.

\textbf{IPv6 Ready}
\label{subsub:ipv6Ready}

The IPv6 Ready Logo \footnote{\url{https://www.ipv6ready.org}, accessed 2.3.2016} is ``a conformance and interoperability testing program intended to increase user confidence by demonstrating that IPv6 is available now and is ready to be used''. Its mission ``is to define the test specifications for IPv6 conformance and interoperability testing, to provide access to self-test tools and to deliver the IPv6 Ready Logo'' \cite{ipv6ready}.

The procedure to obtain the certification and the possibility to exhibit the IPv6 Ready Logo on the products is to first download the test specifications. After that it is possible to use a self-testing tool or to submit the product to specialized and approved laboratories.

IPv6 Ready project entered the phase 2 and version 4.06 of the test since 2010. Phase 1 indicated ``that the product includes IPv6 mandatory core protocols and can interoperate with other IPv6 equipments'', while Phase 2 indicated ``that a product has successfully satisfied strong requirements stated by the Logo Committee''.

The project produced a detailed set of documents\cite{ipv6readyCore}\cite{ipv6readyCore2} which indicate the required network topology, as well as the detailed list of tests to be performed against each protocol. Tests are organized in sections based on RFCs, and inside each section in groups defined by their functionalities, e.g. Address Resolution and Neighbor Unreachability Detection for the section RFC 4861. Inside the section it is defined the scope, which describes broadly the content of the RFC, and the default packet of the message type (ICMPv6).

In each group, e.g. ``Address Resolution and Neighbor Unreachability Detection'', the tests are described with a purpose, e.g. ``Verify that a node correctly determines that a destination is on-link'', the references inside the specifics RFCs, and the test setup with each packet definition, with the fields that differ from the mentioned default packet setup. Then the procedure to perform the test is shown, divided into parts. 

The project covers all the RFCs in scope with this research with extensive tests, with great emphasis on RFC 4861, which is divided in three groups:
\vspace{-10pt}
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Address Resolution and Neighbor Unreachability Detection
 \item Router and Prefix Discovery
 \item Redirect Function
\end{enumerate}

Tests cover the expected functionality, specified by the RFC, but also the behavior of nodes in case of manipulation of the messages, e.g. a wrong Code field.

From the perspective of this research the test quality is very good, and it covers many possibilities to attempt to gain a foothold from the outside to the inside network. 

\subsection{Covert Channel}
\label{sub:covert}


In the context of an attack, malicious actors can exploit a vulnerability to gain a foothold in the internal perimeter. This is a kind of scenario that concerns many actors, but it is not the only one. There is another scenario to take into consideration, especially because of APTs and the amount of resources they have. The case that the malicious actor has already gained a foothold and want to exfiltrate data without authorization. The absence of a proper authorization is an important concept, because it includes in the scenario also persons that are authorized to access the network, like employees, but have no authorization to send information outside the internal perimeter.

This scenario is characterized by the flow of the attack, from the internal perimeter to the outside, and by the need, from an attacker point of view, to stay undetected and, at the same time, to be able to pursue its goals. 

The analysis of this scenario is presented next, and it is usually referred to with the presence of a covert channel.

Before attempting to analyze the scenario characterized by a covert channel in a networked communication, it is necessary to describe the context in which it came out first, that is, the Prisoners' Problem. This is important, because there are many similarities between the Prisoners' Problem and the context of a covert channel: two communicating actors, or processes, a warden, and a communication path that must be submitted to a policy in order to be allowed.

\textbf{The Prisoners' Problem}
\label{subsub:prisoners}

The Prisoners' Problem involves two actors that ``have been arrested and are about to be locked in widely separated cells'', and a warden, who ``is willing to allow the prisoners to exchange messages in the hope that he can deceive at least one of them into accepting as a genuine communication from the other either a fraudulent message created by the warden himself or else a modification by him of a genuine message''\cite{prisoners}.

In the context of a networked communication, ``Alice and Bob exploit an already existing communication path, corresponding to two arbitrary communicating processes: the sender and the receiver. Wendy is a warden, located somewhere along the communication path, monitoring all possible messages exchanged by Alice and Bob''\cite{lewandowski}.

In the analyzed scenario the attacker represents both the sender process located in the inside network, and the receiver process, located outside. The warden is a firewall, or a router, which allows specific communications from the inside to the outside, regulated by the organization's security policy, standards, and procedures. The challenge for the attacker is to find a communication path, which is allowed in the specific traffic direction flow, and use it as a covert channel, in order to deceive the countermeasures in place to consider it as a legitimate traffic.

\textbf{Related Research}

Covert channels are broadly divided into two categories: storage and timing. While the former implies a process that write into a shared resource, e.g. a protocol header field, the latter is based on the timing of events. Timing covert channels needs a synchronization mechanism, a clock in the receiving process which allows to measure the timing of events. For this reason, and because of its complexity, noise, and lower bandwidth, ``[f]rom the attacker's point of view, network storage channels are preferable to timing channels''\cite{milevaPanajotov}. 

This research, because of the complexity of timing covert channels, considers only storage covert channels.

Lewandowski's research defines a communication model for network storage channels, which involves two parties who wish to communicate covertly. ``As a cover, Alice and Bob might either select a suitable, already ongoing communication or generate an appropriate one if they can do so without arousing suspicion, and then they proceed to modify the cover communication’s content to transmit their information. Meanwhile a third party, Wendy, positioned somewhere on the covert communication’s path, attempts to disrupt Alice and Bob’s efforts while preserving the integrity of the cover traffic''\cite{lewandowski}.


The author extracted six scenarios (see~\cref{fig:commScenarios}) from the model, based on the work of Lucena\cite{lucena}.

\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.6\textwidth]{communicationScenarios}
\caption{Communication Scenarios\cite{lewandowski}}
\label{fig:commScenarios}
\end{center}
\end{figure}

The six scenarios depict different positions of Bob and Alice in the communication model, and the way the cover traffic (m) is manipulated by the covert channel (m\textprime).

The first scenario is the simplest one, it involves a communication between Bob and Alice, where Alice uses directly the covert channel and inserts the manipulated message, which is directed to Bob, the receiver. The remaining scenarios explore different combinations, depending on the behavior and identity of the sender, i.e. if Alice is the sender and introduces a manipulated message in the channel, or Alice modifies an existing and legitimate one, or on the behavior and identity of the receiver, i.e. whether Bob is the receiver or, where he is not, if he restores or not the original message after reception\cite{lewandowski}.

``In these scenarios, Wendy always should be positioned between Alice and Bob so that she can monitor m\textprime\hspace{2pt} traffic. Were she positioned differently, and were unable to see m\textprime, her presence would be irrelevant to the covert communication''\cite{lewandowski}.

For the scope of this research, it is assumed that the sender can control the covert channel and insert directly the manipulated message. This reduction in scope, with respect to Lewandowski's study, is justified by the limitation in time, and by the simplicity of the network configuration used for the experiment, which will be highlighted later in next chapters. However, it is worth saying that for an exhaustive testing of ICMPv6, related to covert channels, there are interesting implications to analyze inside the other scenarios, like the ability to preserve the covert channel in situations where Alice must modify the original message of the sender, or Bob must restore the original message before forwarding it to the legitimate receiver.

This assumption, however, has some implications:

``Alice can modify the traffic to a greater degree, since Bob does not necessarily expect the traffic to be meaningful and perhaps not even valid. On the other hand, if Alice and Bob use their own traffic to provide cover, they run a greater risk of exposure as they are openly communicating''\cite{lewandowski}. Furthermore, in this research, it is assumed that the sender and the receiver are different processes, but controlled by the same subject, the attacker.

Another topic to take into consideration, which relates to the behavior of the active warden, is the system and semantics preservation. The concepts have been applied first to preserve steganography \footnote{``The art or practice of concealing a message, image, or file within another message, image, or file'', \url{http://www.merriam-webster.com/dictionary/steganography}, accessed 24.3.2016}\cite{lucena2}, but ``the definitions can be applied to covert channels as well''\cite{lewandowski}.

In the context of covert channels, ``the property of syntax preservation determines whether the modified traffic m\textprime\hspace{2pt}adheres to the protocol syntax. On the other hand, the property of semantics preservation guarantees that the meaning of modified traffic m\textprime\hspace{2pt}is the same as the original traffic m, or in other words that covert channel communication performed by Alice and Bob does not alter the meaning of cover traffic''\cite{lewandowski}.

The above concepts acquire more relevance in a complex topology scheme, where an IPv6 packet must eventually traverse multiple wardens. Lewandowski's work defines the concept of ``location-based syntax and semantics preservation'', which is useful to differentiate between nodes, along the path, ``performing distinct functions'' and with ``multiple levels of protocol knowledge and understanding''. Each node, with a particular function in the network, may behave differently with respect to the packet in travel, and ``as a result, a modified traffic’s syntax or semantics might be deemed correct by an IPv6 node with limited protocol knowledge while at  the same time be rejected by a more knowledgeable node''\cite{lewandowski}.

This concepts will assume a particular relevance for this research when building the experiment. As it has been said before, it is important not only to understand the ICMPv6 protocol by itself, but also its relationship with devices like firewalls (the active warden) and the different configurations which produce different scenarios. Each configuration may lead to a different knowledge and understanding of the protocol by the node, which may affect the ability to preserve the covert channel, and must be taken into consideration. 

For example, it is worth to mention the reserved and unused fields, which are present in some message's headers. The receiver must ignore them, they have no meaning and any modification does not change the semantics. If the syntax is not altered, these fields may be ideal candidates for covert messages\cite{lewandowski}. Therefor, choosing a different configuration for the device, a firewall or router, may affect the level of knowledge of the protocol of that device, and the ability to preserve the covert channel. Or, in the other way, each scenario may produce different behaviors with the presence of a covert channel, and allow to assess a particular configuration and its ability to prevent it.

\textbf{Properties of Covert Channels}

Lewandowski's study proposed six properties of covert channels which are important for the investigation. In this research, given its scope, two of them have been considered:
\vspace{-10pt}
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item ``degree of packet alteration – syntax- and semantics-preservation level of altered packets''. Since each configuration can have different syntax- and semantics-preservation level, it is important to test each covert channel against each configuration, to assess both the warden configuration and the covert channel in this particular scenario\cite{lewandowski}.
 \item ``channel bandwidth – amount of data that can be transfered in given covert channel per packet of cover traffic''. This property does not affect the existence of the covert channel, but its ability to be preserved for a longer period. Depending on the bandwidth, a covert channel may be useful, from attacker perspective, only in situations with a low amount of data to be exfiltrated, or when it is possible to insert a delay in the transmission to avoid suspicion on the traffic\cite{lewandowski}.
\end{enumerate}

Lewandowski observed that some of the considered protocols, Neighbor Discovery is an example of them, ``are designed for operation on a single network segment''. As a consequence, ``any covert channel using these protocols as a cover will be similarly limited in its range'', and ``the communication can be easily defeated by simple address-based filtering mechanism''\cite{lewandowski}.

This research, even though the observation may be correct, will not consider its assumption. The reason is given, as stated before, by the fact that it is important to consider also the actual transition period, where the two protocols, IPv4 and IPv6, coexist in many configurations. This scenario implies that both networks are in place, but the active warden is configured to inspect only IPv4-related protocols, thus with a low level of syntax and semantics preservation knowledge, and any IPv6 packet will transit without deep inspection. For the same reason, an address-based filtering mechanism for IPv6 would probably not be in place. Another aspect, still related to the active warden, is the direction of the communication, from the inside to the outside: since it is considered a communication from a trusted to an untrusted network, the default configuration may allow the traffic without restrictions.

\textbf{Defense Against Covert Channels}

The first line of defense is the identification of a covert channel. Identification try to analyze the shared resource, i.e. header fields, during the design phase. Detection is the mechanism used to reveal an active covert channel. To detect and eliminate running covert channels it is possible to use protocol scrubbers, described in \cite{protocolScrubbers}, traffic normalizers, and the aforementioned active wardens. Protocol scrubbers and traffic normalizers try to find and eliminate ambiguities in the traffic flow. Active wardens and traffic normalizers analyze incoming traffic and modify outgoing packets based on their knowledge of the protocol, e.g. setting to zero reserved or unused fields. Active wardens have different level of knowledge, and abilities to detect and eliminate attacks, depending on the type, which can be stateless, stateful, and network-aware. Stateless wardens have no knowledge of previous traffic. Stateful wardens can detect flows of traffic and base its decision accordingly to preceding knowledge of the flow. Network-aware wardens have also the knowledge of the network topology. In case of ICMPv6, it is possible to limit covert channels by disabling some message types, or limiting the protocol size and rate\cite{milevaPanajotov}.

\subsection{Existing Tools}
\label{sub:tools}

\textbf{cctool}

Lewandowski built a tool called \textit{cctool} in order to perform the tests. The tool has the ability to ``verify the existence of the covert channels, as well as to test the functionality of active wardens''. The results of his tests are strictly dependent on the quality of the wardens and on the scenarios used for the tests, which include also the possibility to modify the traffic in transit\cite{lewandowski}.

It is also worth mentioning some of the assumptions he made in order to better understand the tests. The syntax and semantics preservation are important factors in scenarios where the active wardens have the capabilities to understand, at different levels, the protocols. For example, Lewandowski built a scenario, called Cover Correctness Test, where a sender produces ICMPv6 traffic which is manipulated by Alice, but there is no receiver, namely Bob, at the end. The correctness of the covert channel, in this case, is demonstrated by the fact that an ICMPv6 Echo Request reaches the destination and an ICMPv6 Echo Reply is generated as usual. For such a test, ``the conclusion is that the covert message embedding by Alice does not disrupt the cover traffic enough to impede its normal functionality''\cite{lewandowski}.

One limitation of this kind of tests, as the author specified, is that many covert channel cannot be tested, in particular where an answer is not expected back.

Another type of scenario, instead, include also Bob, who is able to receive the message and restore it back to its initial, syntactically and semantically correct, version. In this case it is possible to test also messages which do not include an answer in its processing rule, because the test environment expected that ``both sender and receiver are located on a controlled network''\cite{lewandowski}.

The results performed by Lewandowski using cctool showed that the manipulation of the Source Address was defeated by the wardens. The tests on ICMPv6 implied an Echo Request, with correctness measured with the answer, resulted in a half of them defeated in the case of the manipulation of the Code field, while the covert channels were successful in case of the Data field manipulation.

\textbf{v00d00N3t}

Another interesting tool that have been built with the purpose to test covert channel in ICMPv6 is \textit{Voodonet}, or v00d00N3t. The purpose of the tool is to use ICMPv6 Echo messages as a covert channel to tunnel traffic. Covert Channel is embedded in the Data portion of Echo Reply message: the tool could send ``Echo Reply messages with a  payload of 1440 bytes in payload with no problem''. The capabilities of the tool is to send and receive data from keyboard (chat) or as text files. Another interesting functionality, which increases the ability to maintain the covert channel, is a time- or bytes-based mechanism to throttle the dispatch of the data\cite{voodoo}.

The two mentioned tools have been built mainly with testing purposes in mind. There is a suite of tools, instead, which has broadly functionalities and it is supposed to be used for penetration testing purposes: thc-ipv6.

\textbf{Thc-ipv6}

The thc-ipv6 attack toolkit\footnote{\url{https://www.thc.org/thc-ipv6/}, accessed 4.4.2016} is a ``complete tool set to attack the inherent protocol weaknesses of IPV6 and ICMP6, and includes an easy to use packet factory library''. The suite includes many features that could be used to test the IPv6 protocol in general, and the ICMPv6 protocol in particular\cite{thc}.

\textit{Alive6} is a tool used to check aliveness of IPv6 systems, both remotely using public addresses, and locally by taking advantage of an ICMPv6 Echo Request sent to the multicast addresses\cite{thc}.

\textit{Parasite6} can be used to perform a Man-in-the-middle attack to the internal LAN by exploiting the Neighbor Discovery process, and sending Neighbor Advertisements to nodes with the attacker MAC address and the IPv6 address of the requested node\cite{thc}.

Another interesting tool is \textit{redir6}, which use ICMPv6 redirect messages. The proposed technique takes advantage of the Redirect Header as an option for the Redirect message, which includes the IPv6 header and the data\cite{thc}.

It is interesting to highlight that the cited paper, dated 2006, took into account the transition scenario and emphasized the possibility to attack the dual stack if proper filtering were not in place for both IPv4 and IPv6.


\subsection{Summary}

Inside this section, this research started to analyze the background, that is RFCs documents. RFCs are documents developed as an agreement to define standards upon which the Internet is built. The two main documents which are in scope with the research are RFC 4443 and RFC 4861, which define the ICMPv6 messages format and the processes for which they have been developed. Besides the header formats, RFCs include directives to the protocol implementation, using terms like MUST and SHOULD. 

After that, the IPv6 Ready project has been presented. The project's aim is to evaluate the readiness of the different products to IPv6 with an extensive set of tests based on the RFC specifications. The project offers, in many aspects, to analyze the opposite network flow direction with respect to covert channels, from the outside to the inside network.

This research started to examine Covert Channels. This is a step on analyzing both directions of the network traffic flow, from the inside and trusted network to the outside. Even though a covert channel may exist in both directions, it is useful to understand, for example in case of APT, that an attacker may already have a foothold in the network and wants to exfiltrate sensible data to an outside address. In this context it is important to consider the presence of wardens, firewall or routers, that may disrupt the covert channel. For such a reason, during the experiment, will be noteworthy to consider different scenarios based on different warden configurations.

The research continue by presenting the existing tools. Two of them, cctool and v00d00N3t, have been built to test the covert channels. The third is a suite of tools, or toolkit, which has been thought to perform security tests on IPv6 and ICMPv6.

In order to conclude this chapter, it is noteworthy to say that all the documents so far presented, if not otherwise specified, are, with different degrees, relevant for this research. The RFCs establish the base of the research, while the other documents offer an insight to understand the contest of some attacks and the reasons behind the choice to perform the tests.

\pagebreak

%------------------------------METHODOLOGY-----------------------------------
\section{Methodology}
\label{sec:3}

The second chapter of this research starts by analyzing the background. The analyzed RFCs define the type of messages that compose the ICMPv6 protocol. For each message the RFCs specify the header and the fields, and the behavior of the protocol to fulfill its functions. The specifications include how to validate a message, the mandatory and optional fields, the data that each field must, should, or may deliver. The language uses the terms must, should, may in order to underline what is mandatory to include in the implementation of the protocol, what it is better to include, and what may or not be implemented, leaving the developer more freedom in how to implement a task. The RFCs represents the knowledge about the protocol. The observation of the rules could lead to think if it is possible to break the rules in some way, and what could happen if different implementors interpret them in a different way.

Another observation regard the environment on which the protocol operate: a network based on a specific protocol suite. The Internet is a complex environment composed by devices interconnecting each other, using many protocols. This complexity makes the Internet an environment not suitable to try to find an answer to the questions derived by the observation. This is because the amount of variables that it introduces do not allow to derive a unique consequence from an action, and thus reliable conclusions. In order to be able to derive reliable conclusions the environment must be simplified and be controllable. A controlled procedure needs to have exactly one variable, and to achieve that a particular configuration must be defined. A specific configuration of the environment represents a constant, thus allowing to modify a specific rule. A set of tests is performed using manipulated rules against a well defined configuration. Then the same set of tests can be performed against another configuration, leading to a number of tests equal to the number of configurations multiplied by the number of elements in the set.\cite{secExperiments}

After the process of observing the background, and the environment in which the ICMPv6 protocol operate, this research found that the best methodology to follow is the scientific method. The reason behind the choice is that many elements of the analysis in the second chapter, and the observation of the data, lead to the formulation of questions and hypothesis, that could be validated, or negated, by experimentation. As it will be better explained next, the process of the scientific method is ideal to test the hypothesis derived by the research questions, taking into account different configurations of the environment.

\subsection{Scientific Method}
\label{sub:sciMeth}

The scientific method has its roots in the ancient Greek philosophy, with Plato and Aristotle. The human reasoning has been the basis for the scientific evolution and studies, with the expression of an hypothesis, the argumentation about the truth or untruth, and eventually the formulation of a theory.\cite{carroll}

An important distinction is between quantitative and qualitative research. Quantitative research is based on the use of statistics or on data that are quantifiable and measurable, in order to produce a result which is not biased on some context and, thus, could lead to a generalization of some theories. Qualitative research, instead, introduces the contextualization and relies on the context in which it is possible to observe a given phenomenon, which is more related to the human science, where observation and definition of a context in which human beings interact may allow to validate or not an hypothesis.\cite{kaplan}

This research uses both a quantitative and qualitative approach to perform the experiment. The qualitative approach is necessary to set up the experiment because of two factors: the choice of the tests and the considerations about the context. The tests are chosen starting from the description of the protocol inside the RFCs, which are for their nature not representable in a mathematical way. Among all the possible tests, some of them are considered for the experiment. The context is also very important and it involves the observation of human behavior in the configuration of the border network devices and the choices of the implementers of the end devices. The quantitative approach arises after the definition of the test set. Each test is performed against a well defined configuration. The set of tests and a specific configuration is an experiment where the only variable is the test itself. In this way, this research is considering the quantitative approach, because inside the experiment, after its set up, no other variable other then the specific test will change, thus allowing it to be measurable in a binary way: either failed or succeed. The conclusions of the experiments, however, because of its context-dependent nature, could not lead to the formulation of a mathematical evaluation. In other words it wont be possible to state that the ICMPv6 protocol is vulnerable by itself, but only that, given this specific configuration, the protocol introduces some vulnerabilities.

Following the work of Peisert and Bishop in \textit{How to Design Computer Security Experiments}, this research defines the following steps:
\vspace{-10pt}
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Form hypothesis
 \item Perform experiment and collect data
 \item Analyze data
 \item Interpret data and draw conclusions
\end{enumerate}

In addition to the aforementioned steps, Peisert and Bishop define three qualities, the most relevant in the domain of computer security, that the procedures requires. The procedures must be falsifiable, which means that the experiment must not be set up in order to justify a positive answer, but to test hypothesis that may ends up to be false. The procedures must be controlled, which involves the presence of exactly one variable. The procedures must be reproducible, which assumes that it is possible to repeat the experiment and obtain the same result.\cite{secExperiments}

\subsection{Research Questions and Hypothesis}
\label{sub:reearchQandH}

The research questions are the starting point in order to define the hypothesis. Research questions express what the research want to know about the specific topic, and leads to definition of an hypothesis, which represents what the researcher want to validate (or invalidate) through the experiments. This research starts with a general research question, from which two additional and more specific research questions have been derived.

\textbf{Research Question}
\label{subsub:researchQ}

\textit{Is it possible to manipulate the ICMPv6 protocol and, by traversing border network devices, use  a network in an unauthorized way?}

This question is a generalization which broadly introduces what this research want to know and test in relationship with the ICMPv6 protocol. Since the question introduces too many variables, it is useful and necessary to narrow down the scope, by defining two more specific research questions.
\vspace{-10pt}
\begin{enumerate}
 \item \textit{Is it possible to exfiltrate data without authorization, from an internal network to the outside, traversing a border network device, by manipulating the ICMPv6 protocol?}
 \item \textit{Is it possible to gain unauthorized access to an internal network, from the outside and traversing a border network device, by manipulating the ICMPv6 protocol?}
\end{enumerate}

\textbf{Hypothesis}
\label{subsub:hypothesis}

The formulation of the hypothesis follows the research questions. The hypothesis is the statement that the experiment aims to validate, which, following the aforementioned qualities of the process, may be negated by the experiment itself and by the following interpretation of data and conclusions.

The hypothesis of this research is:

\textit{It is possible to manipulate the ICMPv6 protocol to use a remote network in an unauthorized way, after traversing a border network device}

Even though this research will prove the truth of this hypothesis, some clarifications are necessary, and the final discussion inside the conclusions will take them into account. The first consideration is related to the general hypothesis itself, which, given its generality, may be less interesting from a scientific point of view. As stated before, each test and configuration is an experiment that may lead to prove the truth of the hypothesis for this exact experiment. The truth is related to a single experiment in the context of a general hypothesis, and the more experiments evaluate to true, the more relevant will be the results. It is very important to emphasize and understand that once a single experiment evaluate to true, the general hypothesis will be proved to be true. In other words, the truth of the hypothesis is the result of the logical \textit{or} of the set of tests performed against each configuration. From this point of view the two more specific research questions, and the two sub-hypothesis, are more relevant because by narrowing down the problem, they define more specifically the context and give more indication about the results. The two sub-hypothesis are:
\begin{enumerate}[ref=hypothesis \arabic*]
 \item \label{firstHyp} \textit{It is possible to manipulate the ICMPv6 protocol to exfiltrate data without authorization from an internal network to the outside and traversing a border network device}
 \item \label{secondHyp}\textit{It is possible to manipulate the ICMPv6 protocol in order to traverse a border network device and gain unauthorized access to an internal network}
\end{enumerate}

The keywords of the first hypothesis are \textit{exfiltrate data without authorization}. While the meaning of the first hypothesis is clear, the second one may be confusing. The keywords of the second hypothesis are \textit{gain unauthorized access}. With gaining unauthorized access, this research do not refer only to the action of controlling a device remotely, but includes also the access to a process to stop it from working (i.e. denial of service), the access to a process to change its behavior (i.e. man in the middle), or the access to informations related to the organization of networks and devices (i.e. reconnaissance).

The assumption done before, that is, that the truth of the hypothesis is given by the logical \textit{or} of the set of tests performed against each configuration, acquires more relevance in the case of one of the sub-hypothesis, because a more thorough specification of the problem has been made.

As it will be discussed in the conclusions, the relevance of the results is an important topic. This is because the aim of this research is not only to prove the truth or untruth of the hypothesis, but also to evaluate the relevance of the chosen wardens, the border network devices. The more robust is the ICMPv6 protocol and its processing rules, the less relevant is the presence of the firewall in order to block or allow a packet.

\subsection{Experiment Foundation}
\label{sub:expFound}

As shown before, the first step of the scientific method involves the definition of the research question, which in this case led to two sub-questions, and the formulation of the hypothesis and sub-hypothesis. The next step involves the execution of the experiment. This research will describe the experiment implementation in detail during next chapter and its execution afterwards. Before that, it is important to discuss the foundation of the experiment, that is, the choices and reasons behind it.

The selection of the test set is a critical task because it is the input of the experiment.

\textbf{Test set selection}
\label{subsub:testSel}

``[T]he truth or falsity of every hypothesis is to some extent conditioned on the input data set [...] an additional step in testing a hypothesis is the validation of the input data set''\cite{secExperiments}. The statement underlines the importance of the test set selection discussed in this section.

Inside chapter two (see~\cref{sec:2}), this research analyzed two RFCs which describe the ICMPv6 protocol and its messages. The analysis had the purpose to show the background of this research and to underline the basis to select the test set for the experiment.

In the context of the set of tests, the ICMPv6 fields acquire relevance to prove the truth of the first hypothesis, that is, the use of ICMPv6 to exfiltrate data from an internal network. Each field has been designed to carry data to fulfill a specification of the protocol. In the case of the data exfiltration described in this research, where the attacker controls both processes of sending and receiving data, only the border network device may perform some checks to validate the compliance with the protocol. The protocol itself may be used just as a transport vector for some data, by means of its fields, with the exception of the destination address specified in the IPv6 protocol, which is necessary to forward the packet to its destination. In addition, each field implies an important indication for the purpose of exfiltrating data, the bandwidth. In fact, depending on the size of the field and of the data to be exfiltrated, it is possible to predict beforehand how many packets the process will use. This research, during the experiment, manipulates each ICMPv6 field against each border network device configuration, in order to test the hypothesis and assess the behavior of the warden.

RFC 4443 and RFC 4861 describe the specifications of each ICMPv6 message and the processing rules in terms of what must, should, or may be implemented. These specifications and processing rules define the behavior of the protocol in relationship with the functions for which it is used by other processes or protocols. While to test the first hypothesis both the sending and receiving processes are controlled by the attacker, the second hypothesis implies that the attacker controls only the sending process. In fact, if a packet successfully traverse the border network device, it is the behavior of the protocol and the implementation of the end device, i.e. the receiving process, to be under testing. In other words, it is the ending device that determines the truth of the hypothesis in case a packet has been able to reach it. Since the ICMPv6 protocol defines messages used in different contexts and with different scope, the Internet or a single network segment, the tests must follow this difference. The test set used against Error and Informational message types is chosen by selecting the rules that must be enforced and are defined by the Processing Rules section of the RFC. Instead, the test set used against the ND protocol, will follow an iterative methodology. Because of its link-local scope, the tests will be selected after the exploitation of a particular attack inside the internal network has been successful.

The next step is the experiment environment and the reasons behind the choices.

\textbf{Environment}
\label{subsub:enviroment}

The environment has been chosen taking into account the possibility to test the hypothesis and properties related to the methodology. To test the hypothesis, the experiment must include an attacking machine positioned in an outside network, which border is delimited by a border network device. The attacking machine is responsible for the receiving process in testing the first hypothesis (see~\ref{firstHyp}), and it is used to send the manipulated ICMPv6 packets in testing the second hypothesis (see~\ref{secondHyp}). The network configuration includes two wardens, a dedicated Cisco Adaptive Security Appliance (ASA)\footnote{\url{http://www.cisco.com/c/en/us/support/security/asa-5505-adaptive-security-appliance/model.html}, accessed 12.10.2016}, and a Linux host with firewall (i.e. Netfilter services) capabilities. Each experiment uses only a warden with a specific configuration. The details of each configuration is discussed in the next chapter (see~\cref{sec:4}). The environment includes two end devices, one Linux host and one Windows host. End devices' purpose is to be responsible for the sending process in testing the first hypothesis (the Linux host), and, when testing the second hypothesis, to receive the ICMPv6 manipulated packets.

The choice of the devices for the experiment has been made taking into account the availability of the devices or virtualized environments. For virtualized environments, one limitation was the available memory (8GB) on the laptop used to develop the Proof of Concept (PoC) and to host the virtual machines. The first research about the environment aimed to have a complete virtualized environment. The difficulties in that research arose in finding a virtualized environment for one of the warden, because one of the objectives of this work is to test a security device which may be used in production systems, like a Cisco firewall. Since there are no freely available images, this possibility has been abandoned. After a bit of research, it has been possible to obtain a physical device (ASA firewall) on University's laboratory, which also has the advantage to decrease the overall need of memory for the virtualization. The virtualized environment is built on top of VirtualBox\footnote{\url{https://www.virtualbox.org/}, accessed 12.10.2016}, chosen because it is available as open source software with GNU General Public License (GPL) version 2\footnote{\url{http://www.gnu.org/licenses/old-licenses/gpl-2.0.html}, accessed 12.10.2016}, and supports for many guest operating systems. The second warden is a Debian Jesse\footnote{\url{https://www.debian.org/releases/jessie/}, accessed 12.10.2016} Linux virtualized guest, which uses iptables\footnote{\url{https://wiki.debian.org/iptables}, accessed 12.10.2016} to configure firewall services. The virtualized environment has been chosen also for the two end devices, a Debian Jesse guest OS and a Windows 7 guest OS. In this case Debian Jesse has been chosen because it is a Linux open source OS, and because a Linux-based machine could be used as a server in production environments. The Windows 7 guest, instead, may represent common workstations in an internal network, and a virtual image could be downloaded\footnote{\url{https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/windows/}, accessed 12.10.2016} with a free trial license. The last device to consider is the attacking device, which had a constraint: because of the physical firewall, also that machine must be a physical device to form a network segment with the firewall. This constraint at the beginning posed some issues, because of a limited availability of devices. After some research the choice has fallen on a Raspberry Pi\footnote{\url{https://www.raspberrypi.org/}, accessed 12.10.2016} with a Kali Linux OS. The reasons behind this choice is both on Kali Linux and Raspberry Pi as an attacking/pentesting device. Kali Linux has support for Raspberry Pi, and it is possible to download a pre-built image from Offensive Security website\footnote{\url{https://www.offensive-security.com/kali-linux-arm-images/}, accessed 12.10.2016}, which are the creators of Kali. In addition, Raspberry Pi with Kali Linux may be a choice for attackers as a portable hacking station. Its dimension may allow to hide it or to use it without causing suspicion in places where the use of a laptop is not common.


\textbf{Border Network Device Configurations}
\label{subsub:borderConfig}

The firewall device, or service, is a key point in the security of the internal network of an organization. The market offers the state-of-the-art products, which include high performances in terms of forwarding capabilities, processing power, deep content inspection, services. Nevertheless, what make a firewall a security device that protect an internal network is the configuration. Most of the products include a default configuration, which must be perceived as a base, a starting point that should be tuned to the requirements of the organization. The default configuration may be enough to cope with the most common attacks, but from an attacker point of view it is sufficient to discover just one entry point in order to pass through. This is even more effective considering an APT.

The hypothesis of this research includes a firewall, as a border network device, because of the belief that the better way to test the ICMPv6 protocol is by correlating the implementation in end devices with the configuration of the firewall. Of course, each protocol may be vulnerable by itself, because of both its design or implementation, and dedicated research must be done as well. Nevertheless, there are scenarios in which, even if the exploitation of a vulnerability is possible, the surrounding environment may be a challenge for an attacker, reducing the likelihood to reach his goals.

Each firewall configuration represents a scenario, and an experiment, in which there is a set of tests and an end device. The set of configurations considered for this research is not exhaustive. The reason is that, even though there are best practices, each configuration must be fine-tuned for a particular set of requirements. The intent of this research is to show what may be the choice of different actors, based on different budgets.

A Linux-based machine, with firewall services, may be the choice of an organization with a low budget. Instead, a company with more resources may choose a dedicated device. This broad category includes organizations without security specialists, which may use the default configuration, or companies with the needed expertise to follow best practices. 

In order to deploy meaningful configurations for the experiment, this research examined documents, best practices and RFCs. 

The first document has been written by the National Institute of Standards and Technology (NIST)\footnote{\url{http://www.nist.gov/}, accessed 12.10.2016}, which has a dedicated chapter on firewall policy and a sub-chapter on IPv6. Inside the section there is a statement that shows how much has to be done for IPv6 and ICMPv6, which says ``[b]ecause IPv6 deployment is still in its early stages, there is not yet widespread agreement in the IPv6 operations community about what an IPv6 firewall should do that is different from IPv4 firewalls''. The suggestions inside the document are more related to filtering packets with an invalid source or destination addresses, for example a link local address arriving at the boundary from the outside network. Another advice suggests to block all IPv6 traffic in the case that the organization do not use IPv6. For what is related to ICMPv6, the document suggested to refer to RFC 4890, which will be examined next in this chapter.\cite{nist}

The second document have been draft by the National Aeronautics and Space Administration (NASA)\footnote{\url{http://www.nasa.gov/}, accessed 12.10.2016} by means of the Communications Service Office (CSO), and used for the NASA Integrated Communication Services (NICS) contract\footnote{\url{https://cso.nasa.gov/content/about-cso-and-nics}, accessed 12.10.2016}. The document describes best practices related to IPv6 in detail. The relevance for this research is limited, because the document refers mostly to internal networks. Specifically, in the chapter related to firewall rules, the document warns about the need of Neighbor Solicitation and Advertisement messages in order for the Neighbor Discovery protocol to work\cite{nics}.

The most important suggestions for this research are described in RFC 4890. Chapter 4 divides firewall rules in two main categories, which, inside, define five broad sub-categories. The main categories are related to ICMPv6 transit traffic, and ICMPv6 local traffic. The following are the five sub-categories:

\vspace{-5pt}
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Messages that must not be dropped
 \item Messages that should not be dropped
 \item Messages that may be dropped in firewall/routers
 \item Messages that administrators may or may not want to drop depending on local policy
 \item Messages that administrators should consider dropping
\end{enumerate}
Inside each category the RFC defines ICMPv6 messages that belongs to it, which in fact allows to build firewall rules accordingly\cite{rfc4890}.

In addition, the RFC cites messages and technologies which are not in scope with this research: these messages are not taken into consideration.

The last source is related to the configuration of a Linux-based host with firewall services. The source also refers to RFC 4890, but as the author states, do not cover all the advices from there. Nevertheless this is a very good starting point to implement the Linux-based scenario of this research\cite{ip6tablesGiobbi}. In addition, there is a basic script\footnote{\url{http://www.cert.org/downloads/IPv6/ip6tables_rules.txt}, accessed 22.4.2016} that is downloadable from the main Computer Emergency Response Team (CERT) website, hosted by the Carnegie Mellon University\footnote{\url{http://www.cmu.edu/}, accessed 22.4.2016}. 

Based on the above described information, this research decided to implement the following configuration categories:
\vspace{-10pt}
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \label{confCategories}
 \item Linux-based firewall services using ip6tables\footnote{\url{http://ipset.netfilter.org/ip6tables.man.html}}, forwarding without filtering
 \item Cisco ASA firewall with default configuration (without ICMP module)
 \item Cisco ASA firewall with ICMP module
 \item Linux-based firewall services using ip6tables, with RFC 4890 ICMPv6 best practices
\end{enumerate}


\textbf{Testing/Attacking application}
\label{subsub:framework}

The experiment part of this research includes a Proof of Concept (PoC) which is able to manipulate and send ICMPv6 packets to test the hypothesis. The PoC is written in Python\footnote{\url{https://www.python.org/}, accessed 22.4.2016}, with an external library to manipulate ICMPv6 messages, called Scapy\footnote{\url{http://www.secdev.org/projects/scapy/}, accessed 22.4.2016}.

Python is a programming language which is possible to use in scripts, with functions, and with object oriented programming. It is installed by default in most Linux distributions and allows to use many third party libraries related to computer security and network testing. Example of that is a project supported by Open Web Application Security Project (OWASP)\footnote{\url{https://www.owasp.org/index.php/Main_Page}, accessed 22.4.2016}, called OWASP Python Security Project\footnote{\url{http://www.pythonsecurity.org/}, accessed 22.4.2016}.

Scapy is a very flexible tool that allows to build packets for many protocols. It allows to use the default protocol implementation, but it is also possible to manipulate packets or create new protocol from scratch. In addition, it allows to control the process of sending and receiving packets, and to visualize the content in different formats in order to build detailed reports. For these reasons, it is the ideal library to build a PoC for the experiment.

Scapy has also some limitations: the IPv6, and ICMPv6, implementations inside the official release have some bugs, which have been solved inside the development version. This research used therefor the development version, which implements also the new ICMPv6 fields that are specified in RFCs which have not completed the necessary approval steps\cite{rfc4884,rfc3775,rfc4191,rfc4389}.

\subsection{Summary}
\label{sub:methConclusions}

This research started this section by presenting the methodology, which is based on the scientific method. After a brief historical introduction, there is a description of the steps that the scientific method involves, starting from the research questions, which form the basis for the hypothesis, then going through the experiment, the analysis of the data, and finally the interpretation and conclusions.

After the general introduction of the methodology, this chapter went through the definition of the hypothesis that have to be tested during the experiment. The general hypothesis produced two more specific hypothesis, which are in relationship with the traffic flow direction of the ICMPv6 packets, from the internal network to the outside, and from the outside to the internal network, both of them traversing a firewall.

The next step in the chapter has been to describe the foundation of the experiment. This research first defined the reasons behind the choice of the test set for each hypothesis. The environment is another important aspect, with the choice of the involved devices which, sometimes, has been conditioned by the available resources.

The configuration of the firewall, as border network device, is another important topic, because each configuration represents a scenario. A scenario is a representation of what might be the choice of an organization for a firewall, based on aspects like the available budget, or the needed expertise to configure it.

Finally, this chapter introduced the components used to build the testing/attacking PoC, which are python as programming language and scapy as packets manipulating library.

The next chapter will dig deeper into the implementation of the experiment, with the details of each involved component.

\pagebreak

%------------------------------IMPLEMENTATION-----------------------------------
\section{Implementation}
\label{sec:4}

The chapter is divided into four main parts. The first represents the technical details of each involved device. The second represents the network used to test both hypothesis, and the steps to go from the first to the second network configuration. The third describes in deep each firewall configuration. The fourth part is dedicated to the PoC and the Test Set.

\subsection{Technical Details - Devices}
\label{sub:technicalDetDev}

\textbf{\underline{Virtualbox}}

\vspace{-10pt}
Virtualbox is the virtualized environment used to host the Linux Debian device, the Windows 7 device, and the Linux Debian Firewall.

\textbf{Virtualbox version:} 

\vspace{-15pt}
VirtualBox Graphical User Interface Version 5.0.24_Debian r108355

\textbf{\underline{Raspberry Pi with Kali Linux}}


\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|L{5cm}|}{Model}&\multicolumn{2}{|L{5cm}|}{OS}&\multicolumn{2}{|L{5cm}|}{OS and Software Update}\\
\hline
\multicolumn{2}{|c|}{Raspberry Pi 2 Model B}&\multicolumn{2}{|c|}{Kali Linux}&\multicolumn{2}{|c|}{31.08.2016}\\
\hline
\end{tabular}}
\caption{Raspberry Pi implementation}
\label{table:raspImpl}
\end{table}
\end{savenotes}

The OS has been downloaded\footnote{\url{https://www.offensive-security.com/kali-linux-arm-images/}}, and updated on 31.08.2016 with the following commands (common for all Linux devices, root privileges required):
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
 apt-get update
 apt-get upgrade
 apt-get dist-upgrade
\end{lstlisting}

\vspace{-10pt}
\textbf{Kernel version (uname -a):}

\vspace{-10pt}
Linux mazinga 4.1.19-v7 \#1 SMP Tue Mar 15 15:10:00 CDT 2016 armv7l GNU/Linux


\textbf{/etc/network/interfaces:}

\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
auto lo
iface lo inet loopback

allow-hotplug eth0
iface eth0 inet6 static
	address 2001:db8:acad:1::2
	netmask 64
	gateway fe80::1
\end{lstlisting}

\textbf{Python version:} 

\vspace{-10pt}
Python 2.7.12+

\textbf{\underline{Linux Debian}}

\vspace{-10pt}
\textbf{Guest configuration}:

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|L{5cm}|}{Base Memory:}&\multicolumn{2}{|L{5cm}|}{Processor:}&\multicolumn{2}{|L{5cm}|}{Video Memory:}\\
\hline
\multicolumn{2}{|c|}{2048MB}&\multicolumn{2}{|c|}{2CPU}&\multicolumn{2}{|c|}{24MB}\\
\hline
\end{tabular}}
\caption{Linux Debian}
\label{table:linuxDeb}
\end{table}
\end{savenotes}

The OS has been downloaded from debian website\footnote{\label{deb1}\url{https://www.debian.org/releases/jessie/debian-installer/}, installed and the updated on 31.08.2016}.

\textbf{Kernel version (uname -a):} 

\vspace{-10pt}
Linux debian 3.16.0-4.amd64 \#1 SMP Debian 3.16.7-ckt25-2+deb8u3 (2016-07-02) x86_64 GNU/Linux

\textbf{First Hypothesis - Network Configuration (/etc/network/interfaces)}
\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet6 static
	address 2001:abcd:acad:2::2
	netmask 64
	gateway fe80::1
\end{lstlisting}

\vspace{-10pt}
\textbf{Second Hypothesis - Network Configuration (/etc/network/interfaces)}
\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet6 auto
\end{lstlisting}

\textbf{Python version:} 

\vspace{-10pt}
Python 2.7.9

\textbf{\underline{Linux Debian Firewall}}

\vspace{-10pt}
\textbf{Guest configuration}:
\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|L{5cm}|}{Base Memory:}&\multicolumn{2}{|L{5cm}|}{Processor:}&\multicolumn{2}{|L{5cm}|}{Video Memory:}\\
\hline
\multicolumn{2}{|c|}{1024MB}&\multicolumn{2}{|c|}{1CPU}&\multicolumn{2}{|c|}{12MB}\\
\hline
\end{tabular}}
\caption{Linux Debian Firewall}
\label{table:linuxDebFirewall}
\end{table}
\end{savenotes}

The OS has been downloaded from debian website\cref{deb1}.

\textbf{Kernel version (uname -a):} 

\vspace{-10pt}
Linux debian 3.16.0-4.amd64 \#1 SMP Debian 3.16.7-ckt25-2+deb8u3 (2016-07-02) x86_64 GNU/Linux

\textbf{Network Configuration:}

\vspace{-10pt}
\textbf{/etc/network/interfaces}
\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet6 static
	address 2001:db8:acad:1::1
	address fe80::1
	netmask 64

auto eth1
iface eth1 inet6 static
	address 2001:db8:acad:2::1
	address fe80::1
	netmask 64
\end{lstlisting}

\vspace{-10pt}
\textbf{/etc/sysctl.d/99-sysctl.conf}

\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
 net.ipv6.conf.all.forwarding=1
\end{lstlisting}

\vspace{-10pt}
\textbf{Python version:} 

\vspace{-10pt}
Python 2.7.9

\textbf{\underline{Windows 7}}

\vspace{-10pt}
\textbf{Guest configuration}:

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|L{5cm}|}{Base Memory:}&\multicolumn{2}{|L{5cm}|}{Processor:}&\multicolumn{2}{|L{5cm}|}{Video Memory:}\\
\hline
\multicolumn{2}{|c|}{512MB}&\multicolumn{2}{|c|}{1CPU}&\multicolumn{2}{|c|}{27MB}\\
\hline
\end{tabular}}
\caption{Windows 7}
\label{table:windows7}
\end{table}
\end{savenotes}

The OS has been downloaded from Microsoft website\footnote{\url{https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/\#downloads}, installed on 24.10.2016}.

\textbf{OS Version}:

\vspace{-10pt}
Microsoft Windows 7 Enterprise, 32 bit, OS version 6.01.7601 Service Pack 1 build 7601

\textbf{Network Configuration:}

\vspace{-10pt}
Network Auto configuration of IPv6.

\textbf{\underline{Linux Debian External Device}}

\vspace{-10pt}
\textbf{Guest configuration}:

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|L{2.5cm}|}
\hline
\rowcolor{lightblue}
\multicolumn{2}{|L{5cm}|}{Base Memory:}&\multicolumn{2}{|L{5cm}|}{Processor:}&\multicolumn{2}{|L{5cm}|}{Video Memory:}\\
\hline
\multicolumn{2}{|c|}{1024}&\multicolumn{2}{|c|}{1CPU}&\multicolumn{2}{|c|}{24MB}\\
\hline
\end{tabular}}
\caption{Linux Debian External}
\label{table:linuxDebExt}
\end{table}
\end{savenotes}

The device has been cloned from Linux Debian to test the ICMPv6 Redirect (Type 137) for the second hypothesis.

\textbf{\underline{Cisco ASA Firewall}}

\vspace{-10pt}
\textbf{Model:} 

\vspace{-15pt}
Cisco Adaptive Security Appliance (ASA) 5505 Series

\textbf{Version:}

\vspace{-10pt}
The version of the device and its component is visible in~\cref{AppendixCiscoVer}.


\subsection{Network Configurations}
\label{subsection:netConfigurations}

The network configurations (see~\cref{fig:netConfiguration1} and~\cref{fig:netConfiguration2}) used to run the experiment are very similar and differ for a few details: the presence of the Windows box, and of the External device inside the second configuration. In addition the second configuration requires some changes in the addressing schema, by using an automatic configuration.


\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.7\textwidth]{networkTopology1}
\caption{Network Configuration to test first hypothesis}
\label{fig:netConfiguration1}
\end{center}
\end{figure}

In~\cref{fig:netConfiguration1} is represented the configuration to test the first hypothesis (see~\ref{firstHyp}). The context is given by an attacker who has gained a foothold on the internal network, but also by a disgruntled employee, whose aim is to exfiltrate data without authorization.

The network configurations are very simple and are not reflecting a production environment of a company. The reason behind this choice is to have a controlled environment, where it is possible to modify one variable at a time, which is a mandatory constraint to test the hypothesis.

Another choice in~\cref{fig:netConfiguration1} is the use of a single internal device. There are two reasons behind that. The first is related to the PoC, which is written in python with a focus on a Linux environment. The second reason is related to the two processes, in the context of data exfiltration, which are both controlled by the attacker: the sending process is managed by the PoC in the Linux Debian internal host, while the receiving process is running in the external host. Since both processes are not controlled only by the network stack implemented in the kernel of the devices, this research decided that a test using another device (the Windows host) would have been less interesting, while adding more complexity in writing the PoC.

The firewall, in both figures, is a general representation of a device with firewall services. During the execution of the experiment, the whole test set related to the hypothesis is run against each device and configuration. The difference between each configuration is discussed in detail later in this chapter, while the figure shows the common characteristics, the IPv6 addresses of the two interfaces, one linked to the internal network, and one to the ouside world.

In~\cref{fig:netConfiguration2} is represented the configuration to test the second hypothesis (see~\ref{secondHyp}).

\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.7\textwidth]{networkTopology2}
\caption{Network Configuration to test second hypothesis}
\label{fig:netConfiguration2}
\end{center}
\end{figure}

In this scenario, the attacker controls the external device and want to test the possibility to use the internal network and hosts in an unauthorized way. The scenario, and hypothesis, is more oriented to test the implementation of ICMPv6 in different OSs, therefor the introduction of an additional device. The presence of only two OSs is another limitation in scope of this research. A Linux device may be the choice for a server offering services for an enterprise, and a Windows 7 device simulates an employee workstation. Further research should take into consideration a broader set of OSs.

\textbf{Network Configuration, from First to Second Hypothesis}
\label{subsub:netFromFirstToSecond}

To test the second hypothesis it is necessary to accomplish some more steps. Since the Neighbor Discovery protocol is involved, the IPv6 address of the end devices, internal Linux Debian and Windows 7, is auto configured after receiving a Router Advertisement from the firewall.

While for the ASA Firewall this is the default behavior, the Debian Linux Firewall needs an additional package in order to send Router Advertisement, which could be installed as follows:

\vspace{-10pt}
\textit{apt-get install radvd}

\vspace{-10pt}
After the package is installed, edit the configuration file in /etc/radvd.conf, as follows:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
 interface eth0 { 
        AdvSendAdvert on;
        MinRtrAdvInterval 5; 
        MaxRtrAdvInterval 10;
        prefix 2001:abcd:acad:2::/64 { 
                AdvOnLink on; 
                AdvAutonomous on; 
                AdvRouterAddr on; 
        };
};
\end{lstlisting}
\vspace{-15pt}
The process must be activated, after the device starts to act as a router (by forwarding packets), with the following command:

\vspace{-10pt}
\textit{systemctl start radvd}


\subsection{Firewall Configuration}
\label{subsection:firewallConf}

The configuration of the warden is a key point of this research. The firewall is the border network device that provide the line of defense of an enterprise network towards the external IPv6 world, where the IPv6 internal addresses are routeable and reachable.

The firewall configuration inside this research is also used as a way to simulate different requirements, budget, and expertise that an enterprise may have. These three characteristics must be carefully evaluated by an organization, and a balance between them must be found. The requirements are usually to have the maximum level of defense, and are evaluated against the budget of the enterprise. The configuration of the appliance is crucial, and requires the needed level of expertise, which is strongly dependent on the available budget and on the awareness of the management.

Finally, since this research's goal is to test the ICMPv6 protocol, the different configurations of the firewall must be chosen in a way that takes into consideration the boundaries of the test possibilities. This is accomplished by having four configurations, where two of them represents the boundaries of the test space. This concept will be developed next, inside each configuration description.

\textbf{\underline{Netfilter Open}}
\label{subsub:netfilterOpen}

This firewall configuration represents the lower limit in the test space, where packets are forwarded but not filtered.

As it is possible to see in~\cref{appendix:netfilterOpenApp}, the netfilter configuration enables IPv6 packets forwarding in the linux kernel, and explicitly accepts packets in the forwarding chain of the filter table.

This open configuration offers the possibility to reach two goals. It simulates a bad practice that may arise in the transition period, where the IPv4 protocol suite is the choice of an organization, but IPv6 is already active in the private network. The term simulation, here, is used on purpose, because the forwarding of IPv6 packets is not active by default. Nevertheless, it may stimulate the necessary awareness in the audience regarding the transition period and the need to deal with IPv6.

The second goal is to test the design and implementation of ICMPv6 by itself. This configuration allows to test the protocol in a direction which is close to the aforementioned IPv6 Ready Project (see~\cref{subsub:ipv6Ready}), in the contest of the second hypothesis. In addition, the configuration allows to evaluate the design of the ICMPv6 protocol and the fields in its messages in the contest of data exfiltration, which is related to the first hypothesis. The latter may be of secondary importance for the goals of this research, but, nevertheless, from the point of view of a network protocol's designer, could be interesting to think about how a protocol must rely on third party devices and configurations, like routers and firewalls, to avoid that some fields are used in a different way with respect to the semantic for which they have been created.

\textbf{\underline{ASA Default Configuration}}
\label{subsub:asaDefault}

The Cisco Adaptive Security Appliance is a device that may be the choice of small to medium organizations. When first fired on, it is possible to do some basic configurations to allow it to be operational by configuring and activating some basic features, like the IP/IPv6 address of the interfaces and their security level, the default being a security level of 100 for the inside interface, and a security level of 0 for the outside interface.

This kind of configuration may not be sufficient to protect the organization, and it is not in most cases, but it is a representation of a bad practice that leads to buy a professional, in some cases expensive, appliance, with the feeling that it is enough to protect the enterprise's business assets. This configuration simulate also the lack of the necessary expertise, both from a management and technical point of view. The management should evaluate the needs of both the appliance and the technical expertise to configure it.

The configuration file (see~\cref{appendix:ASAdefaultAppendix}) shows the configured parameters, with just few of them modified from the default: the IPv6 address of the two interfaces, the activation of ssh for management purposes, hostname, domain, and the encryption of the passwords. In order to activate IPv6 it is sufficient to configure the IPv6 address on the vlans associated to the network interfaces.

\textbf{\underline{ASA with ICMP module}}
\label{subsub:asaDefaultICMP}

This configuration adds an important features with respect to ICMPv6: the activation of the ICMP module on the global policy, in order to allow deep packet inspection on the ICMPv6 packets. It is worth noting that the ASA configuration uses the term ICMP for both ICMP and ICMPv6.

In the case of this configuration, the management evaluated the needs of the appliance, but also the needed expertise to do the necessary configuration, which for this research considers an ICMPv6 only world. In other words, a production environment must take into consideration the services offered by the enterprise and add the required configuration, which involves the creation of access lists to determine the packets to allow in and out the internal perimeter.

The configuration file (see~\cref{appendix:ASAicmpAppendix}) shows, under the \textit{policy-map global_policy} section, the added ICMP module.

\textbf{\underline{Netfilter with Best Practices}}
\label{subsub:netfilterBestPractices}

The last firewall configuration is represented by a Linux device with netfilter services. This choice represents the necessary expertise to configure a border network device to deal with ICMPv6, and, in the mean time, the use of an unexpensive device with an open source software to provide the filtering services. In terms of awareness, it means that the management may have chosen to invest in expertise rather then in the device itself, in a context where the budget has some limitations.

The configuration file (see~\cref{appendix:netfilterBestAppendix}) has been developed starting from a script published by the CERT website \footnote{\url{http://www.cert.org/downloads/IPv6/ip6tables_rules.txt}, accessed 22.4.2016}, and modified to fullfill this research requirement using RFC 4890 (which also contains an example script)\cite{rfc4890}. In addition, the original script has been thought for an host-based firewall, an end device, with rules applied to the input and output chains of the filter table. This research, instead, required a device for packets in transit, in addition to the packets with the firewall as destination. This involves the forwarding chain, where the best practices for the communication between the internal network and the rest of the world have been applied.

It is worth to mention this configuration as a contribution of this research. As it will be described next, the rules applied to the different chains allows to understand better some functionalities of ICMPv6, which may be useful from a didactical point of view to introduce security practices in network classes.

\textbf{Ip6tables Rules (Netfilter Service)}

The script with best practices rules has comments that introduce each block of rules. An analysis of each block with the rules follows.

The first block contains variables related to the two network interfaces of the firewall, and the IPv6 addresses, which identify the internal and external network linked to them.

The second block allow to activate packet forwarding in the linux kernel. The command allows a temporary activation of the service, which last until a reboot of the OS.

The following block is the reset of the rules that may be present in previous configurations: it erases the rules and the user created chains, and clear the statistics of the packets. The statistics represents a very useful tool to understand, and verify, how the rules behave and which packets are blocked or enter a particular chain. The following command shows the statistics:

ip6tables -L -n -v

Then, ad hoc chains have been created. This step may not be necessary in terms of functionality, but it allows to better understand the organization of the code. This research point of view is that readability and clear code is a security best practice, which should be applied not only in software engineering, but also in writing small script. The first two chains shows the network flow directions, which are mainly related to the two hypothesis. The two additional chains allows to establish an ssh connection to the firewall device, and to the attacking device, for monitoring purposes.

As the comment suggests, the next block applies the default policy in a whitelist way, which is dropping packets entering the chain by default, if there is not a rule matching the entry. The white list approach has advantages, but also drawbacks to take into considerations. In terms of security, this is the better approach, in contrast to the blacklist approach. The reason is that the blacklisting procedure allows to block, or filter, what is well known, which could be the signature of an attack, or an IPv6 address known to be the source of an attack. The problem arises for new attacks, or packets that the security practitioner is not aware of being part of an attack, which, with this approach, are forwarded. The whitelist approach, instead, denies the access for all but the known and authorized packets. It is the task of the administrator to provide the rules to allow the forwarding of the packets.

The whitelist approach requires a very good understanding of the network, of the behavior of the protocols, and of the services allowed on the network. Since all is denied by default, also authorized packets are blocked until not explicitly allowed. This may disrupt the network and break the availability of some services.

The following blocks define rules to apply to the input and output chains, the chains of the filter table to manage packets with the firewall network interface address as destination (input chain), or for packets that originate from the firewall device (output chain). This rules are needed for the correct operations of the local network segments, i.e. to allow protocol like the Neighbor Discover to work correctly.

The rules, applied against the forwarding chain that appear next, regulate packets with addresses which are valid in the local network only, like link-local and multicast addresses.

The script, then, defines the rules to enter in the aforementioned ad hoc chains: the source and destination addresses for the ICMPV6-TO-OUT chain, and the destination address for the ICMPV6-TO-IN chain. Both of them match the ICMPv6 protocol only.

The first analyzed rules regard packets originating from the internal network and forwarded to the outside. The ICMPv6 error message types are accepted and forwarded, since their function are needed for the correct operation of IPv6. The two informational messages are treated in a different way: Echo Requests are allowed but rate limited, while Echo Replies are droped. While the former rate limitation is not strictly necessary with today network bandwidth, the latter is a choice of this research, based on a possible organization's policy. Most of the examined documents, during this research, put the attention on the fact that, due to the huge address space in IPv6, it is no more necessary to filter Echo Request from the outside to deny network scan operations and the map of the internal network. This research is taking another approach, which follows the whitelist approach phylosophy. The functionality may be useful to test the reachability, from the outside, of some internal devices, e.g. a server in the DMZ. This functionality, however, may be needed during the initial configuration, or after some critical updates, but not during the everyday activity. It is the opinion of the researcher that it is a better practice to deny the forwarding of messages that are not needed for every day work, while it is possible to craft special configurations (in this case may be to allow one specific IPv6 source address to test reachability) to deal with special cases.

The remaining rules of this ICMPV6-TO-OUT chain are related to the Neighbor Discovery (ND) protocol. Here the choice of this work is to comply explicitly with the RFC (\cite{rfc4861}) and allow the forwarding of ND messages only if the hop limit is equal to 255. This has the equivalent effect of denying the messages, since, in the forwarding process, the device decrement by one the hop limit, resulting in a value of 254, and therefor being droped by the policy. The last two rules allow to log the droped messages, and to explicitly drop the remaining, not matching, packets. The last rule is redundant because of the policy, and it is there just to show the last rule to apply in case the policy is to allow packets by default (blacklisting).

The last block of rules, the filtering of packets to be forwarded in the ICMPV6-TO-IN chain, reflects the choices of the preceding block. The ICMPv6 error messages are allowed to be forwarded. The informational messages are divided into the Echo Request, denied by the organization's policy, and Echo Reply, allowed as answer to an Echo Request from the internal network. The ND messages, instead, are explicitly droped, which, as said, accomplishes the same effect previously described with the hop limit of 255, which is to deny the forwarding of the packet.


\subsection{Proof of Concept (PoC) and Test Set}
\label{PoCandTest}

\textbf{\underline{PoC}}

The PoC for the experiment could be found at:

\vspace{-10pt}
\url{https://github.com/antekirtt/thesis/tree/master/python/code}

It is possible to download a zip file with all the thesis material, or in alternative to use git:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\footnotesize]
 git clone https://github.com/antekirtt/thesis.git
 cd python/code/
\end{lstlisting}

\vspace{-15pt}
\textbf{Requirements:}

\vspace{-10pt}
The PoC has been written and tested for Linux Debian and Kali Linux.

The following libraries for python are required:

\vspace{-5pt}
\underline{\textit{scapy}:}

Version 2.3.2_dev\footnote{\url{https://github.com/secdev/scapy}, accessed 31.8.2016}.

\textit{Note:} the version used in the Kali and Debian repositories is 2.3.2. This version has some bugs related to IPv6 that have been solved in the development version.

To download and install the library:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\footnotesize]
 git clone https://github.com/secdev/scapy.git
 cd scapy
 python setup.py install
\end{lstlisting}

\underline{\textit{bitstring}:}

Installed on 31.08.16 in all the devices that use the PoC.

To install the library:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\footnotesize]
 easy_install bitstring
\end{lstlisting}

The PoC is started at command prompt as follows (root privileges required):

./icmpv6 -i eth0

with the mandatory -i option defining the network interface to use.

The picture (see~\cref{fig:pocMain}) shows the initial screen and some basic function, the help command with explanation of possible commands, and the command completion obtained by pressing the tab key twice.

\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.6\textwidth]{pocMain}
\caption{PoC initial screen}
\label{fig:pocMain}
\end{center}
\end{figure}


Help and command completion are available along all the sections of the PoC.

The PoC is divided into two main parts, each related to the test of each hypothesis.


\textbf{PoC - First Hypothesis}


The PoC related to the test of the first hypothesis is contained in the file named allCovertTest.py. The main class inside the file, AllCovertTests, defines some variables and the main method ``startSystem''. The variable ``dataToExfilt'' defines the second part of the data to be exfiltrated, which is the following: : 

\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 :this is the super secret data to exfiltrate to our attacking machine\n
\end{lstlisting}

\vspace{-15pt}
The above data is concatenated with the name of each message type and field. For example, the complete data for Destination Unreachable type, and the use of the Code field to embed the data, is the following:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 Destination Unreachable code :this is the super secret data to exfiltrate to our attacking machine\n
\end{lstlisting}

For each message type, a class is defined, and it is responsible to build the packets to send. In addition to the initialization, each class contains two kind of methods. The first is a set of methods, one for each field of the message, which follows the pattern ``buildPacket'' plus the name of the field. It is responsible to build each single packet using the functionalities of Scapy. The second is common to all the classes, it is called ``execModule'', and it is responsible to initialize the packets, and send them after the data has been divided to fit the field bandwidth. The last functionality is achieved using an helper class, which contains a family of methods to be used depending on the bandwidth of the field, and on the way that Scapy manages internally some type of data (e.g. address fields).

One challenge of the functionality that allows to chunk the data to fit each field has been to find a data structure, and a methodology, that allows to send the data from one side, and rebuild the same data on the other side. Most of the variables representing the fields in Scapy are integers, which is a problem because integers are not represented with a fixed length. For example, the ascii decimal code for the character ``c'' is 99, while for character ``d'' is 100. The concatenation of the two, in case of two byte bandwidth, is 99100. Since the length is variable, on the other side would be more complicated to split it into two different bytes, and characters.

The algorithm used to achieve the functionality is the following (the example shows the methodology used with multiples of one byte bandwidth, for simplicity):

First, data has been divided into chunks accordingly to the field's bandwidth. Then, from each chunk, the single character is processed and transformed in its binary representation using the bitstring package. Each binary representation is added to the preceding one, with a resulting binary number which is a multiple of one byte. The binary representation is transformed back in an integer, which is sent.

On the receiving side it is possible to transform back the integer in a fixed length binary number, divide it into bytes, and obtain the ascii code wich is displayed as a character.

Another important file to test the hypothesis is named receiver.py. The Receiver class uses the functionality of the packet sniffer inside the Scapy library, filtering the packets by their IPv6 destination address. This could be considered the weekest part of the PoC: the packet sniffer itself, and the implementation to get the data, sometimes get some unwanted packages, leading to show some garbage on the screen. This is caused by the presence of network protocols data that the receiver is not able to filter appropriately, which may lead to the corruption of data. However, the result of the experiment is not affected by this issue, which is confirmed by intercepting the data using Wireshark\footnote{\url{https://www.wireshark.org/}, accessed 11.10.2016}, on the destination device, and by analyzing it. Nevertheless, an improvement of the receiver is needed in the evolution of the software.

\textbf{PoC - Second Hypothesis}

The PoC to test the second hypothesis is different with respect to the first one, in terms of organization of the code and involved processes. 

Since the simulation involves the control of just one process by the attacker, the sending process, the PoC reflects this condition. Another difference, as will be analyzed in the next section, is that each test must be performed individually, and the behavior examined in the end system target by other means. The configuration of the IPv6 address is no more required for this set of tests: each command is tied to a specific target. This choice is also related to the IPv6 auto configuration mechanism, because the generated address is more complicated to memorize and configure each time the target should be changed.

The commands to execute the experiment are located into two different file: \textit{infoAndErrorAttacks.py} and \textit{neighbDisc.py}. 

Inside the latter there are also the commands to verify the internal attacks. They represents a step to define the actual tests, and are not part of the verification of the hypothesis.

Each message type has a unique source file and the functionality broadly reflects the following schema: one class per message, one execution test method per test, with a general method to build the required packet. For some messages, when the building of a packet changes in a significat way between executions, the execution method contains also the functionality to build the packet.

The involved IPv6 address are hard coded in the initialization method of each class, which is the place to modify the code to perform the experiment with different addresses.

\textbf{Test Set - First Hypothesis}

The complete test set for this hypothesis is visible in appendix (see~\cref{table:exfiltrationTestSet}).

The tables shows the fields used as test set. The rows are grouped by message type to show more clearly how many fields, for each type, are used for experimentation.

From the proposed test set there is a consideration that is important for this research: all the field of each message type have been considered for the set. It is worth to remember that RFCs defines the behavior of end systems while processing  the fields of some message types: for example, the unused field in Destination Unreachable and Time exceed messages, or the reserved field in the ND messages, are often pointed out as fields to ignore, or zeroize by end devices or firewalls. Previously in this research, it has been specified the need to evaluate also the design of the network protocols, and not only the implementation. The unused and reserved field must be part of this evaluation, since, even though they may be there to reserve some space for future use, there may be other ways to accomplish future needs. The fields, in fact, are perfect candidates to be used for data exfiltration, because they allow to preserve the syntax and the semantics of the protocol \cite{lewandowski}.

\textbf{Test Set - Second Hypothesis}

The test set used to validate the second hypothesis is very different, in terms of reasoning and goals, from the one used to validate the first hypothesis. Instead of showing the set and the results in different tables, it is possible to see both of them in one table (see~\cref{appendix:resultsSecond}).

The differences in reasoning and goals reside in the nature of the hypothesis and in the way that the results may be validated. First hypothesis is validated in a binary way, either the message representing the exfiltrated data arrives, and shows on the receiver process, or not. The second hypothesis, instead, implies a different kind of validation, because in the case that the tested ICMPv6 message arrives, the resulting behavior of the end system may be the one described by the RFC. In this case, before the validation of the hypothesis, it is necessary to understand the behavior of the end system when the packets arrive.

The table of the test set and results is organized in a different way for the two main type of messages: error and informational messages, and messages related to the ND protocol.

\textbf{Error and Informational messages}

The table is organized with four main columns. The description of the experiment shows some indications about the content of the test: wheather there is a manipulation of the source or destination IPv6 address, or if the value of a field has been modified to test extreme values. The table differentiates between different targets, and then between the four firewall configurations. The last column shows the behavior of the end system when the packets arrive, which also represents the result in the case that the behavior is not the expected one.

\textbf{Neighbor Discovery protocol messages}

The tested ICMPv6 messages defined by the ND protocol have different scope, with respect to error and informational messages: the scope is link local, the network segment which boundaries are defined by a router (phisical device or functionality). This difference in scope led to a different kind of thinking in order to build the test set: instead to try to directly test the hypothesis, it is worth to manipulate the messages and build tests to be performed in the internal network and then select the successful one to be performed from the outside network in order to validate, or negate, the hypothesis.

The tables (see~\cref{appendix:resultsSecond}) reflects this kind of reasoning. Each table related to the ND protocol is divided into two parts. While the second part shows the same columns as for the other ICMPv6 messages, the first part shows a brief description of the type of attack performed internally, and the results for each target. Each test may then be selected for the actual test.


\pagebreak

%------------------------------EXPERIMENT-----------------------------------
\section{Experiment}
\label{sec:5}

The experiment of this research has been designed to test the research question and to validate, or negate, the hypothesis. The third chapter (see~\cref{sec:3}) defines a main research question and hypothesis, which could be divided into two more specific research questions and hypothesis, one for each network flow direction. That is, from the internal network to the external network (see~\ref{firstHyp}), and from the external network to the internal network (see~\ref{secondHyp}).

This chapter is organized to show how to run the experiment. For the first hypothesis a single command on the Debian Linux device starts all the tests in sequence, while another command in the RPKL device starts the receiving process. The second hypothesis, instead, requires different commands for each test, as underlined in the relative section, under subtitles \textbf{Error and Informational messages} and \textbf{Neighbor Discovery messages}. A different network configuration has been designed to test each hypothesis. Each configuration includes an external host, a firewall device, and an internal Linux device. In order too test the second hypothesis, two devices have been introduced: a Window device for the whole test set, and an External (Debian Linux) device to test Redirect messages.

Since one of the goals of this research is to validate, or negate, the hypothesis against different firewall services and configurations, also the device changes accordingly: a Cisco ASA with two different configurations (see~\cref{appendix:ASAdefaultAppendix} and~\cref{appendix:ASAicmpAppendix}), and a Linux device also with two configurations (see~\cref{appendix:netfilterOpenApp} and~\cref{appendix:netfilterBestAppendix}).

It is worth to underline how this research uses the term \textit{experiment} in different ways. Along this document, the term is often used in a general way, indicating the experimentation part of this research. But, as it has been mentioned before, an experiment is also the run of a single test against a firewall configuration and an internal host, in the context of the validation of an hypothesis. This is because the hypothesis may be validated just for that single test, while it is negated for another test, firewall configuration, or host. 


\subsection{First Hypothesis}
\label{sub:firstHypExp}

In order to carry the experiment for the first hypothesis (see~\ref{firstHyp}), it is required to build the appropriate network configuration (see~\cref{fig:netConfiguration1}).

\textbf{Experiment Setup and Run}
\label{subsub:expRun}

In order to setup the experiment it is necessary to prepare the devices as described in~\cref{sec:4}, and the network topology (see~\cref{fig:netConfiguration1}). In addition, the PoC must be downloaded \footnote{\url{https://github.com/antekirtt/thesis}} and installed on the devices with the correct dependencies, also described in~\cref{sec:4}.

The Linux Debian device, in the context of the experiment, is owned by the attacker with root privileges. The Raspberry Pi Kali Linux (RPKL) device is also controlled by the attacker.

The first step to run the experiment is to start the receiver on the RPKL device, with the command:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 ./icmpv6.py -i eth0
\end{lstlisting}

\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.6\textwidth]{runExpReceiver}
\caption{The screen of the receiver}
\label{fig:runExpRec}
\end{center}
\end{figure}

As it is possible to see from the figure (see~\cref{fig:runExpRec}), the only piece of configuration is the IPv6 address of the receiver, the RPKL device.

The second step involves to start the PoC on the Linux Debian device. To start the PoC the same command is issued:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 ./icmpv6.py -i eth0
\end{lstlisting}
\vspace{-10pt}
From the figure (see~\cref{fig:runExpSend}), it is possible to see the commands and the configured IPv6 address.

\begin{figure}[ht] 
\begin{center}
\includegraphics[width=0.6\textwidth]{runExpSender}
\caption{The screen of the sender}
\label{fig:runExpSend}
\end{center}
\end{figure}

The results of the experiment, with all the details, will be discussed in the next chapter.

\subsection{Second Hypothesis}
\label{sub:secondHypExp}

The second hypothesis (see~\ref{secondHyp}) requires to build the appropriate network configuration (see~\cref{fig:netConfiguration2}).

\textbf{Experiment Setup and Run}
\label{subsub:expRun2}

In order to setup the experiment it is necessary to prepare the devices as described in~\cref{sec:4}. In addition, for the first and fourth firewall configurations (Debian Linux with Netfilter services), it is required to perform the modifications described in~\cref{subsub:netFromFirstToSecond}. The PoC must be downloaded \footnote{\url{https://github.com/antekirtt/thesis}} and installed on the devices with the correct dependencies, also described in~\cref{sec:4}.

The Raspberry Pi Kali Linux (RPKL) is controlled by the attacker and it is used to perform the tests to validate, or negate the hypothesis. In addition, in order to perform the internal tests related to the ND protocol, it is possible to use the Debian Linux or the Linux Firewall with open configuration (see~\cref{appendix:netfilterOpenApp}), which requires to download and install the PoC in these devices as well.

The best procedure for the experiment is to first use the Linux Firewall with open configuration, since this kind of configuration grants the generated packets to reach the internal network. In addition, for many test it is useful to monitor the generated traffic, in both directions, from the firewall using an instance of Wireshark, which is installed on the device.

In order to start the experiment, execute the following commands:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 ./icmpv6.py -i eth0
 testing
 attacking
\end{lstlisting}
\vspace{-15pt}
This leads to the part of the PoC used to test the second hypothesis. The PoC is then divided into the two groups of attacks, the first related to error and informational messages, the second related to the ND protocol. 
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 setInfoAndError
    OR
 setNeighborDiscovery
\end{lstlisting}

\textbf{\underline{Error and Informational messages}}

After entering the informational and error section, it is possible to see the commands to perform this part of the experiment. The commands for this section are available in~\cref{table:commands2H} from~\cref{AppendixCommands}. 

\textbf{Destination Unreachable Tests}

The first two tests send, in sequence, a packet with each code and type 1. A wireshark instance is used to monitor the network on the Linux Firewall. This general purpose kind of test may be useful to observe the behavior of end systems when a Destination Unreachable message arrives, in particular to assess if the end systems generate new packages as a response to the messages.

Tests from 3 to 16 are specific for each message code. The goal is to test each code using either the Attacker IPv6 address as source, or the spoofed firewall address. Wireshark is used to monitor the traffic in both the Linux Firewall and the end system target. From each end system, the test includes an HTTP request to the attacker device, an Echo Request, or both, in order to verify if changes occur in the conversation after the reception of the ICMPv6 packets.

Tests 17 and 18 are used to assess the behavior of the end systems against unknown codes.

Tests 19 and 20, instead, are related to the new Length field. The purpose here is to evaluate the end system against a field which is implemented in the used version of Scapy, but not present in RFC 4443~\cite{rfc4443,rfc4884}. Since the Scapy version of the experiment is the development one, it is possible to find some fields which are not yet approved by the IETF. This should not be the case of the implementation of ICMPv6 in the end systems, nevertheless it could be worth to evaluate to which point implementations in OSs (or applications using ICMPv6) are following the directives.

\textbf{Packet Too Big}

Tests from 21 to 26 manipulates the MTU field (minimum for IPv6 is 1280), by sending values which are greater (21-22), smaller (23-24), or in average (25-26) with respect to the minimum required.

Tests 27 and 28 have the aim to evaluate the behavior of end systems with unknown codes.

\textbf{Time Exceeded}

Tests 29 to 32 use the spoofed IPv6 address of the firewall to generate code 0 and code 1 messages. Effects on end systems and network traffic are observed using Wireshark.

Tests 33 and 34 are performed against unknown codes, while 35 and 36 are using the RFC draft Length field with values varying from 0 to 255\cite{rfc4884}.

\textbf{Parameter Problem}

Tests 37 to 42 use respectively code 0 to 2 with the spoofed IPv6 address of the firewall, with Wireshark to monitor traffic, while tests 43 and 44 are performed against unknown codes.

Tests 45 to 48 manipulate the pointer field of the message. The first two tests use, in sequence, low values (0-1024), while the last two use high values from the 32 bit field. The aim is to evaluate the end systems against CPU and memory consumption using Task Manager (Windows) and the top command (Linux).

\textbf{Echo Request}

The aim of the tests for this message type is to evaluate the behavior of the target with respect to Reachability and Neighbor Cache. With tests 49 and 50, the source address is generated to be an on-link address, while the destination is the target end system. Tests 51 and 52 perform the same tests, but using the generated address as destination, and the target end device as source. In order to evaluate the results is possible to use the following commands:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 (Windows) netsh interface ipv6 show neigh
 (Linux)   ip -6 neigh
\end{lstlisting}

\textbf{Echo Reply}

Tests 53 and 54 send packets to the target systems with the source spoofed IPv6 address of the firewall. The goal is to observe the behavior of the target when it receives an Echo Reply with a forged Echo Request in the payload.

Test 55 sends the same packet as test 53, but in this case the host-based firewall of the target has been disabled to observe the behavior of the end system.


\textbf{\underline{Neighbor Discovery messages}}

The commands for this section are available in~\cref{table:commands2H2} from~\cref{AppendixCommands}. Even if are not part of the experiment to test the hypothesis, also the command to perform internal tests are available in the PoC, as in~\cref{table:commands2HInt}. The internal tests have been used as a first step to then define and select the actual tests, and will be briefly discussed later with the results of the experiment.

\textbf{Router Solicitation}

No tests have been selected for this message type. The reason is that internal tests did not suggest a way to use this type as an attacking vector.

\textbf{Router Advertisement}

The tests for this message type are divided into two main categories: the first tests the injection of network prefixes, while the second tests the modification of the MTU value on target devices. 

Tests 56 to 61 have Windows 7 as target, while tests from 62 to 67 have Debian Linux as target. This series of tests are executed sequencially using one command for each end system, because each of them tries to inject a different prefix. Tests variation includes different source addresses (Firewall, Debian Linux, and Windows 7), and different values for L and R flags. To evaluate the behavior it is possible to use \textit{ifconfig} (linux), or \textit{ipconfig} (windows).

Tests 68 and 69 inject an arbitrary MTU value on the target. In order to evaluate the results, it is possible to use the following commands:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 (Windows) netsh interface ipv6 show subinterfaces
 (Linux)   cat /proc/sys/net/ipv6/conf/eth0/mtu
\end{lstlisting}


\textbf{Neighbor Solicitation}

Test 70, with Debian Linux as target, has been selected after the internal test showed that the target started to send Neighbor Advertisement to itself. Source and destination IPv6 addresses are the same.

\textbf{Neighbor Advertisement}

Test 71, performed against Debian Linux, uses an Echo Request with a spoofed internal IPv6 address to induce the target to start the Reachability process, which may be completed by sending a Neighbor Advertisement after the target sends a Neighbor Solicitation. Also this test has been selected after a successful internal attack. The behavior of the target could be observed using Wireshark on the target and the command \textit{ip -6 neigh}.

\textbf{Redirect}

For this tests is necessary to add the External Device, as in~\cref{fig:netConfiguration2}. Tests 72 and 73 aim to verify the possibility to perform an half Mitm attack, by redirecting the target request to the attacker. Use Wireshark on the attacking device to verify the tests.

\pagebreak

%------------------------------RESULTS-----------------------------------
\section{Results}
\label{sec:6}


This chapter exhibits the results of the experiment of this research. It is organized to introduce first how the results are presented. Then, the chapter is divided into the two sub-hypothesis (see~\ref{firstHyp}, and~\ref{secondHyp}) to show for each of them what are the outcomes of the experiment.

The results related to the first hypothesis are presented by introducing some general considerations about the experiment, and by describing how to read the table in appendix that shows the outcomes. After that, for each firewall configuration, this research will explain the results and discuss the differences between them and the expectations before performing the experiment.

\subsection{First Hypothesis}
\label{resultsFirstHypothesis}

In order to test the first hypothesis, this research defined a test set (see~\cref{Appendix 3}). The PoC has being written to validate or negate the hypothesis using each test of the set against each warden configuration, as previously described.

It is worth to remember that, for the experiment to be valid, only one variable at a time must be modified. This variable is represented by the specific firewall configuration, while the other components of the experiment remain constant. For this reason, also the results are presented, along this chapter, in sections named after the firewall configuration that generated them (see~\cref{subsection:firewallConf}).

The results of the experiment are visible in~\cref{appendix:resultsFirst}.

The table with the results is organized by enumerating the tests in the first column to allow a direct reference to each test. Tests from number 1 to 10 included represents the ICMPv6 error messages. Tests from 11 to 18 represents ICMPv6 informational messages. Tests from 19 to 44 use ICMPv6 messages defined by the Neighbor Discovery protocol. Grouping the tests is useful because each group of messages depicts a different broad functionality of the ICMPv6 protocol, and it reflects some expectations about the results of the experiment, which, as it is possible to see, and it will be described next, it is not always the case.

The second and third columns represents respectively the ICMPv6 message type and the field of the message used to exfiltrate data in the covert channel.

The fourth column shows the bandwidth obtained by using the particular covert channel offered by the field, in terms of bytes for each sent packet. The value of the bandwidth is static and it has been measured taking the amount of bits that a field can carry. This value is only theoretically correct, because there is no mechanism in the PoC to manage the retransmission of a lost packet. Nevertheless, this data is interesting in the evaluation of the covert channel and to analyze the possibility that a covert channel will stay undetected for longer: channels with low bandwidth requires more packets, given the same amount of data, for a successful exfiltration, which means a higher chance to be detected.

The fifth column depicts the firewall configuration applied for the test set. It is divided in four sub-columns which represents each configuration. Each sub-column, numbered after the configuration categories defined in~\cref{confCategories}, shows if that specific test validates or negates the hypothesis for that specific configuration.

\textbf{Netfilter Open}
\label{resultsFirstNetfilterOpen}

The tests against this configuration produced the expected results and validate the first hypothesis for this specific configuration (see~\cref{appendix:resultsFirst}).

The Netfilter Open could be seen as the trivial case. The covert channel is dependent from its ability to preserve the syntax and the semantics of the message \cite{lewandowski}, and from the ability of the wardens, along the path to the destination, to catch each modification of those properties. The triviality of this part of the experiment is given by the fact that the warden has no knowledge of the protocol, thus it is unable to detect such modifications. Nevertheless, in the context of the experiment, the tests allow to assess the following:
\vspace{-5pt}
\begin{itemize}[noitemsep,topsep=0pt,partopsep=0pt]
 \item Exploit the possibility for further investigations. In the case that the tests shows the presence of covert channels, it is possible to proceed by investigating more restrictive configurations.
 \item Analyze the presence, or absence, of covert channels in the ICMPv6 protocol by itself, and eventually broaden the discussion to network protocols in general.
\end{itemize}

The table with the results shows that this configuration allows to use a covert channel to exfiltrate data with all the fields of each message, without exceptions.

The experiment to test the first hypothesis suggests that it is useful to proceed by investigating more restictive configurations. Furthermore, since the configuration represents the trivial case, the conclusion of this research is that the ICMPv6 protocol allows the presence of covert channels. In other words, without an active warden which is capable to detect them, the ICMPv6 protocol is not able to prevent covert channels that use its fields to transport information. This conclusion will be further analyzed later inside the comparison of the results.


\textbf{ASA Default Configuration}
\label{resultsFirstASADefault}

The results of the experiment with the ASA with the default configuration have been quite different from the expectations of this research. The table (see~\cref{appendix:resultsFirst}) shows that the ASA has been able to block the covert channels embedded in the ICMPv6 error messages. Instead, covert channels using ICMPv6 informational messages, and messages defined in the context of the Neighbor Discovery protocol, validate the hypothesis for this kind of tests and this configuration.

The expectation of this research was quite the opposite, and it was based on the best practices that came out from the research, and applied to the fourth configuration. The ASA firewall is a dedicated device, which must be configured accordingly to the needs of an organization and its network, and services. In fact, a best practice regarding devices, or applications, is to never leave them in the default configuration, which, in the best case scenario, is something that every malicious actor can guess and try to bypass with public information. Nevertheless, this research's opinion is that the expectation after buying a device like the ASA firewall, is to have a device with minimal operation capabilities with the default configuration, which requires then to be conformed to the needs of the company for what is related to specific services. In other words, in terms of a common protocol like ICMPv6, the expectation is to have something as close as possible to the best practices.

From the table of the results:
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item tests from 1 to 10 included negate the hypothesis
 \item tests from 11 to 44 validate the hypothesis
\end{enumerate}

As mentioned before, tests from 1 to 10 refer to the error messages of ICMPv6. The message types are: Destination Unreachable, Packet Too Big, Time Exceeded, and Parameter Problem. These messages are used by the network to communicate that there are issues of different kind in the delivering of a packet. For example, the Packet Too Big type uses the MTU field to communicate to the source of the packet that some link, along the path to the destination, has a Maximum Transmission Unit that is lower than the one that connects the origin to its first hop. This kind of information is important for the communication to work properly, and should not be blocked by the device.

On the other side, the ICMPv6 messages defined by the Neighbor Discovery protocol, Router Solicitation, Router Advertisement, Neighbor Solicitation, Neighbor Advertisement, and Redirect, are messages employed inside a network segment, inside the LAN, and are not supposed to travel beyond a firewall, or a router. In fact, the best practices state to filter such packets with a Hop Limit lower than 255. This kind of messages must not leave the internal network and must be blocked at the boundaries of the network segment.


\textbf{ASA with ICMP module}
\label{resultsFirstASADefaultICMP}

This configuration adds the deep inspection of ICMPv6 messages by activating the ICMP module.

The table (see~\cref{appendix:resultsFirst}) depicts the results of this set of experiments. The hypothesis is negated by tests from 1 to 11 included, and from 15 to 18 included. For test 12, 13, 14, and from 19 to 44, instead, the experiment validates the hypothesis and allows the creation of covert channels to exfiltrate data.

The expectations of this research, for this set of tests and configuration, was sightly different compared to the previous one. Since the covert channels have been created by modifying the semantics of the fields, with the activation of the deep packet inspection for ICMPv6 messages (the module is called icmp for both ICMP and ICMPv6) this research expected the negation of the hypothesis for all the ICMPv6 message types. Instead, the experiment validates the hypothesis for the Echo Request type, using Identifier, Sequence Number, and Data fields, and for all the messages related to the Neighbor Discovery protocol.

The expectations about the experiment with this configuration were built upon a wrong interpretation of what the deep packet inspection for ICMP and ICMPv6 is able to do. In fact, the module enables the firewall to be stateful with respect to the ICMPv6 protocol, which is by nature stateless. By adding a session to the traffic, the ASA allows the returning traffic, generated by ICMPv6 messages, to pass through the ASA and return back to the host that generated the initial messages. This is the case for an Echo Reply, which return traffic is generated by an Echo Request. In fact, the module allows to open a session only for an Echo Request and not for other type of messages, which are not supposed to expect a return traffic.

The session allows the device to block the covert channels related to the fields of the Echo Reply message, as shown by the results. This is because there are no valid Echo Requests that opened a session and allowed for the trafffic to come back. The ASA searches for an open session, which is not found, and the packet is dropped. From the results, instead, only the covert channel which uses the Echo Request code field has been blocked. The opinion of this research is that this is due to the fact that the ICMP module is looking for a valid code in order to open a session, but it could not find one, since the only semantically valid code for an Echo Request is 0. This opinion however needs further investigations, and a new iteration of the experiment. 

The following command, issued on the ASA cli, can be used to debug and better understand the applied rules:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 packet-tracer input inside icmp 2001:abcd:acad:2::2 128 0 2001:abcd:acad:1::2 detailed
\end{lstlisting}

The command shows in detail when and at which phase a rule may allow or drop a packet. It takes into consideration packets in the input of the inside interface, related to the icmp protocol (ICMP or ICMPv6), which arrived from the given source address. The ICMPv6 message has type 128 (Echo Request) and code 0. The command comfirms that a packet with the given characteristics is allowed to pass the firewall. Test number 11, instead, changed the semantics of the field, which results in a drop of the packet. Another command useful for the investigation is the following:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 show asp drop
\end{lstlisting}
\vspace{-10pt}
The command shows the statistics of the dropped packets (to reset the statistics use the \textit{clear asp drop} command).

To confirm the aforementioned opinion, this research decided to slightly modify to PoC, by commenting all the tests, but the one that uses the Echo Request code field. After clearing the statistics, the experiment is performed. 

The proposed command confirmed the assumption:

\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 ASA-EXP(config)# show asp drop

  Frame drop:
   ICMP Inspect bad icmp code (inspect-icmp-bad-code)                          89
\end{lstlisting}

The test sent 89 packets in order to exfiltrate data, which are inspected by the ICMP module and dropped because of a bad code. In this case, the ICMP module is able to negate the first hypothesis and prevent the covert channel.

Tests from 19 to 44 follows the same reasoning depicted in the previous configuration, that is, the messages defined by Neighbor Discovery must be blocked inside the broadcast domain. 


\textbf{Netfilter with Best Practices}
\label{resultsFirstNetfilterBest}

The table (see~\cref{appendix:resultsFirst}) shows the results of the experiment with the Netfilter configuration with Best Practices. The results fulfills the expectations of this research and validate the first hypothesis for tests from 1 to 14 included. Test from 15 to 44, on the other hand, negate the hypothesis.

The result is fully expected because the best practices, which led to this configuration, clearly define which are the functionalities that a network needs in order to work properly. In addition, the applied best practices divide the functionalities between those that are required by the internal network, and those that are required for an end-to-end communication. For both of them, as described in~\cref{subsub:netfilterBestPractices}, the rules to allow or drop an ICMPv6 message are applied.

Tests from 1 to 10 included use ICMPv6 error messages. Those messages are required to communicate that the network traffic encountered some kind of error, which may disrupt or slow down the communication. The results  were expected because, even though the configuration follows the best practices, the device has not enough knowledge of the syntax and semantics of the protocol, which are the properties to which a covert channel must adhere in order to stay undetected. With the test, the syntax is respected, but the semantics change completely: the values of the fields are meaningless for the message. For example, a Time Exceeded code must always have values between 0 and 1 included, while the covert channel that uses that field modifies the value accordingly to the data it needs to transport.

Tests from 11 to 18 included represent the ICMPv6 informational messages. Here the hypothesis has been validated by the Echo Request tests, and negated by the Echo Reply tests. In this case the difference is not caused by the application of best practices, but by an hypothetical internal policy that a company may have. The policy states that the organization want to be able to test external connectivity and allow return traffic under the form of an Echo Reply. On the other side, the policy grants that an external entitiy would not be able to perform aliveness tests, and for this reason the return traffic is dropped.

Finally, since NDP is required on the internal network only, ICMPv6 messages defined by this protocol are dropped at the boundaries. This negates the hypothesis for tests from 19 to 44.

The Netfilter configuration with best practices is part of the contribution of this research, but it is not enough to detect all the covert channel, as shown by the results. This configuration is able to filter the messages accordingly to the best practices, but in order to disrupt also the covert channels that use the required ICMPv6 messages and fields, another kind of mechanism is needed. This mechanism is the deep packet inspection, which is based on a deeper knowledge of the syntax and semantics of the protocol. The mechanism may be offered by IDS and IPS services like Snort \footnote{\url{https://www.snort.org/}, accessed 19.10.2016}, or Suricata \footnote{\url{https://suricata-ids.org/}, accessed 19.10.2016}. These services are not in scope with this research and will not be further analyzed.


\subsection{Second Hypothesis}
\label{resultsSecondHypothesis}

In order to test the second hypothesis, this research used different approaches. First at all, it was not possible to apply a systematic methodology like during the test of the first hypothesis. The reason is that during the previous tests, the fields of the protocol have been manipulated and used in a complete different way with respect to their semantics. This has been possible because the sending and receiving processes were both controlled by the attacker. The fields under test acquired importance with respect to the ability of the active warden to detect changes in the syntax and semantics of the field. For the second hypothesis, instead, the attacker is able only to send the message, while the manipulated packet may have an effect on the implementation of ICMPv6 at destination, which is not under control of the attacker. In this context, in addition to the active warden, the validation of the hypothesis depends on the enforcement of the rules defined by the RFCs on the target OSs. These rules vary in a sensible way, depending on the purpose and scope of the message. The purpose is different for example between informational and error messages, which have different scope with respect to messages defined by the ND protocol. Because of this difference in scope, messages defined by the ND protocol have been tested inside the internal network first. Then, in case of successful attack, a specific test have been selected to test the hypothesis from the external network.

The results of the experiment are visible in~\cref{appendix:resultsSecond}, and will be discussed next. Since the approach has been different, also the presentation of the results will follow this difference. First, this research will present the table with the results. After that, the results will be disclosed from the point of view of each message type. Inside each message's section are also discussed the effects of a test on the target, and briefly the behavior of the active warden. The presentation of the effects will take into account mostly the configuration of the firewall with Netfilter Open. This configuration allows the packets to reach the target, evaluate potential changes, and assess the implementation of ICMPv6 in the target OSs, which may lead to a validation of the hypothesis for this configuration.

The results are organized into tables, one for each message type. The tables for ICMPv6 with types 1 to 4, 128, and 129, have the same columns. The first column shows the test number. The second includes a brief description of the test, or its specification, e.g. the Code of the message, indications about source and destination, or the nature of the payload. Then, one column shows the target OS, and one, for each firewall configuration, points out if the packet successfuly traveled through the warden. Finally, the target's behavior when the packet arrives, and the validation method used, when it is different from an observation with Wireshark.

The tables related to the ND protocol, instead, include the test selection in their first part. First column shows if the test has been selected, followed by the description of the attack. Then, after the target indication, the last columns exhibits the results of the attack and a brief explanation. The second part of the table follows the same structure as the one described for informational end error messages.


\textbf{Destination Unreachable}

The set of tests related to the Destination Unreachable message negates the second hypothesis (see~\cref{table:attackInternalResults1}).

The first tests sent, in sequence, a packet with each known code. The goal was to verify if the target reacted after reception of the message in violation of the processing rules defined by the RFC~\cite{rfc4443}.

Tests from 3 to 16, instead, tested each message code with different source addresses and payloads. An instance of Wireshark inside the target showed no new packets generated as a reaction to the tests. The verification included an HTTP, an Echo Request, or both, to verify potential effects on the network traffic.

The last tests flooded the target using unknown Codes, and different values for the Length field. It is interesting to note that the latter is not even considered by the instance of Wireshark as a valid field. In fact, this new field uses part of the official Unused field, and Wireshark sees the modification of the value as part of this field.

The results show also a symmetry in the evaluation of the firewall: both Netfilter Open and Netfilter with Best Practices allowed the packets, while the two configurations related to the ASA firewall blocked them. While the first two are expected results, the configurations of the ASA deserve another consideration. The default behavior of the appliance is to block the traffic from a network with a lower security level to a network with an higher security level. This behavior may break the communication between hosts and is against the best practices. From a security point of view, this research thinks that this approach is reasonable and follows a white list methodology, where the administrator must configure access lists for the known services. Nevertheless, this is a confirmation that the default configuration is not enough for this device. A company must be aware that the ASA, without an investment in the necessary expertise for the configuration, will introduce new issues.


\textbf{Packet Too Big}

The set of tests related to the Packet Too Big message negates the second hypothesis (see~\cref{table:attackInternalResults2}).

Since the MTU field represents the Maximum Transmission Unit of the next hop, the tests aimed to verify the possiblity to induce the target to fragment packets, or to send packets too big for the link. After the packets have been received, the validation of the test implied the creation of Echo Requests with different sizes. This is possible using the following commands, respectively for Windows 7 and Debian Linux:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 ping 2001:abcd:acad:1::2 -l [size]
 ping6 2001:abcd:acad:1::2 -s [size]
\end{lstlisting}
\vspace{-15pt}
Wireshark showed no evidence of changes in the network traffic started from the targets. One possible reason for the failure is a lack on matching the process that would cause the Packet Too Big message, which the target should infer from the payload of the message.

The last tests flood the targets with messages with unknown Codes. Also in this case there is no evidence of effects on the targets.

In terms of firewall configurations, the results underlined the same symmetry seen with the previous message: configurations with Netfilter allowed the packets to enter the network, while configurations with the ASA blocked the packets.

\textbf{Time Exceeded}

The second hypothesis has been negated also for the tests related to the Time Exceeded message (see~\cref{table:attackInternalResults3}).

Packets sent first with Code 0, and then with Code 1, produced no evidence of effects on targets, which does not generate additional network traffic after reception of the packets. 

The last tests, flooding the target with unknown Codes and different Lenght values, do not produce evidence of changes on the target. The Length field, also in this case, has been interpreted by Wireshark as part of the Unused field.

As for the other message types, firewall configuration with Netfilter Open and Netfilter with Best Practices allowed the packets to travel across the device, while the two ASA configurations blocked the packets.

\textbf{Parameter Problem}

The test set related to the Parameter Problem message negates the second hypothesis (see~\cref{table:attackInternalResults4}).

Tests from 37 to 42 sent messages with valid Codes, and the firewall's spoofed IPv6 address as source, to the two targets, which showed no evidence of changes. Also, no new ICMPv6 messages have been generated in response to the tests. The same results occured by flooding the target with unknown Codes.

Tests from 45 to 48 also produced no evidence. The idea behind these last tests was to verify the behavior of the target with different values of the Pointer field, which represents a reference, inside the payload, of the octet of the invoking packet where an error caused the generation of the message~\cite{rfc4443}. By sending values between 0 and 1024 first, and then high values closed to the 32 bit upper bound, this research wanted to verify possible anomalies in the CPU and memory utilization on the target. In order to verify this behavior, on Windows system has been used the Task Manager and Resource Monitor, while for Linux the command Top.

The experiment depicted the same symmetry previously seen, with Netfilter configurations allowing the packets on the internal network, and ASA configurations blocking them.

\textbf{Echo Request}

The test set related to the Echo Request message validates the second hypothesis for the Netfilter Open configuration (see~\cref{table:attackInternalResults5}).

The tests used a 16 bit value range to generate as much spoofed IPv6 addresses with the internal network's prefix, and flood the target. The generated addresses have been used as destination addresses, for tests 49 and 50, and as source addresses for tests 51 and 52. The goal of the tests was to induce the target to start the Reachability process and to exhaust the Neighbor Cache.

From the targets it was possible to verify the initial steps of the Reachability process: target inserted the spoofed addresses in the Neighbor Cache and started to send Neighbor Solicitations, and waited for a Neighbor Advertisement to complete the process, which never arrived. The entry in the Neighbor Cache is then put in a failed state.

In addition, with the exception of test 52, both the target device and the Debian Linux Firewall are affected. For test 52, where the source address has been spoofed, the target Debian Linux device droped the packet, while the firewall began the Reachability process.

The impact of the tests on the target devices is low: both targets' Neighbor Cache have a limitation on the stored entries and used a circular data structure, or a queue, to manage them. The first entry in the data structure is also the first erased when the limit has been reached. 

From a network traffic point of view, the tests showed a low impact. Nevertheless, this research want to underline the fact that the network used for the experiment included three devices out of an address space, considering an internal network with 64 bits lenght prefix, of 64 bits. For the future, it is possible to imagine the use of big subnets, for example in the case of small devices used to monitor critical environments (storms, ocean waves, tsunami): in those cases the impact on the network traffic would be higher, and this result should be taken into consideration, either by finding means to mitigate the risk, or by designing networks with a smaller amount of devices.

The results for the firewall configurations do not depict the same symmetry as for the other message types. It is worth to remember that this research included, in the Netfilter with Best Practices, a rule to block Echo Request from an external network: this measure has been defined as a policy choice, not a best practice. The reason is that, from a best practices point of view, an Echo Request is often used to enumerate a network; this practice has been obsoleted by the huge address space of IPv6, which makes infeasible a complete enumeration. Nevertheless, there is an impact on the target network. An organization must take it into consideration and carefully evaluate the possibility to use best practices with additional rules, accordingly to the nature of their network and requirements.

\textbf{Echo Reply}

Test number 55 validates the second hypothesis for Netfilter Open and Netfilter with Best Practices configurations (see~\cref{table:attackInternalResults6}).

Tests 53 and 54 do not show effects on the target systems, which ignored the packets.

Test 55 has been selected after some experiment on a Mitm attack, on the internal network, using Neighbor Advertisements. In order to understand the failure of some early attempts, the Windows 7 firewall has been disabled, to verify if the host-based firewall was the issue.  In that situation, the analysis of the network traffic using Wireshark on the Debian Linux devices showed an unusual Parameter Problem message, with Code 1 (unrecognized next header type). The discovery led to an in-depth analysis of the reasons and additional verifications.

The first verification implied a situation where the target is expected to send back a Parameter Problem message with Code 1. The packet has been crafted with an incorrect Next Header IPv6 field sent to the Debian Linux target. The value could be a number between 143 and 252, which are unassigned \footnote{\url{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}, accessed on 15.11.2016}. The target behaved as expected by sending back a Parameter Problem with Code 1 message. The same test, but performed against the Windows 7 target, with the firewall activated, failed. The deactivation of the host-based firewall, instead, led to a successful test. 

The results of this analysis shows the following:
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item The Debian Linux device is not vulnerable to this enumeration method.
 \item The Debian Linux device behaves correctly after the reception of a packet with an unrecognized next header.
 \item The Windows 7 device, with the Service Pack 1 and default installation (without further updates) is vulnerable.
 \item With this methodology, it is possible to state that the target may correspond to the aformentioned device without an active host-based firewall.
\end{enumerate}

The level of experimentation on this issue does not allow to be more precise, on point 4, on the nature of the target. The experiment should be repeated in an environment, with phisical devices, which include also other OS versions and types. Nevertheless, as a further iteration of this experiment, this research downloaded a Windows 8.1 \footnote{\url{https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/\#downloads}, downloaded on 15.11.2016} device: the experiment, without host-based firewall, has been successful. This last result shows that at least two versions of the Windows OS, and this level of updates, are vulnerable.

\textbf{Router Solicitation}


The second hypothesis has been negated for Router Solicitation messages. No tests have been selected (see~\cref{table:attackInternalResults7}). 

Accordingly to the testing selection for ND protocol, three internal test have been performed, but none of them fulfilled the requirements. Two of them were not successful, while the last used the All Router Multicast Address, which cannot be used from a different network segment.

\textbf{Router Advertisement}

The test set related to the Router Advertisement message negates the second hypothesis (see~\cref{table:attackInternalResults8} and~\cref{table:attackInternalResults9}).

From the internal tests, two attacks have been selected: the injection of an arbitrary prefix, and the change of the MTU for the link, on the targets. This generated tests from 56 to 61 with Windows 7 as target, and tests from 62 to 67 directed to Debian Linux. The tests tried to inject a prefix on the targets, using different addresses as source and by manipulating the flags of the Prefix Information option, without success. The effects on the target can be measured using commands \textit{ipconfig} and \textit{ifconfig}, for Windows and Linux respectively. The probable reasons of the failure are the enforcement of the rule regarding the Next Hop IPv6 field, which must be 255, and of the rule which defines that the source address must have link-local scope~\cite{rfc4861}.

Tests 68 and 69 tried to inject a new MTU value on the targets, without success. The validation is possible with the following commands, respectively for Windows and Linux:
\begin{lstlisting}[style=python,basicstyle=\ttfamily\small]
 netsh interface ipv6 show subinterfaces
 cat /proc/sys/net/ipv6/conf/eth0/mtu
\end{lstlisting}
\vspace{-15pt}
From a firewall configuration point of view, the packets have been forwarded only by the Netfilter Open configuration.

\textbf{Neighbor Solicitation}

The test set related to the Neighbor Solicitation message negates the second hypothesis (see~\cref{table:attackInternalResults10}).

The selected internal test showed a particular behavior of the Debian Linux device. The packets have been sent with a Solicited Multicast source address of the target, which started to send Neighbor Advertisement to itself. Test 70 followed the same concept, but with source and destination Global Unicast addresses of the target, without having the same effect on the target. The reason is again the Next Hop field, which after traversing the firewall is decremented by one.

The firewall with Netfilter Open configuration allowed the packets to be forwarded internally, while the other configurations blocked them.

\textbf{Neighbor Advertisement}

The test set related to the Neighbor Advertisement message negates the second hypothesis (see~\cref{table:attackInternalResults11}).

From the internal test, the attack against the Neighbor Cache have been selected. This attack had two goals: try to exhaust the Neighbor Cache, and override legal entries in the table to produce a DOS condition against the target with respect to other devices in the subnet. Test 71, failed: the first Echo Request started the Reachability process in the target device, but the following Neighbor Advertisement is dropped because of a Hop Limit less than 255.

The Netfilter Open has been the only configuration that forwarded the packet.

It is worth to mention the result and the reasons why the internal Mitm against Windows 7 has not been selected. The Windows device uses by default a temporary Global Unicast address to initiate the conversations, while it uses the permanent one when provides server functionalities or services. In order to perform the Mitm, the attacker pretend to be the Windows 7 device from a firewall point of view, and the firewall from a Windows 7 point of view. This is accomplished by sending Neighbor Advertisements. The issue resides on the fact that the Windows device uses the temporary address to initiate a conversation (e.g. an HTTP request). Without the knowledge of this address, the attacker is able to intercept only half of the conversation, from Windows to the firewall, but not the response. In order to complete the Mitm the attacker needs to announce also the temporary address to the firewall. This address may be disclosed internally after a period (e.g. Reachability process). From an outside network this may happen only if the internal device initiate a request to the attacker machine. For this reason, the test has not been selected.

\textbf{Redirect}

The test set related to the Redirect message negates the second hypothesis (see~\cref{table:attackInternalResults12}).

The goal of tests 72 and 73 was an half Mitm attack, with the Attacker as Redirect Target, and the External device as Redirect Destination. The reasons of the failure may be the Hop Limit and the source address which is not of link-local scope.

The Netfilter Open has been the only configuration that forwarded the packet.


Inside the next chapter this research presents the conclusions after the experimentation and the discussion of the results.

\pagebreak

%------------------------------CONCLUSIONS-----------------------------------
\section{Conclusions}
\label{sec:7}

This research began by introducing the motivations behind the choice to an in-depth analysis of the ICMPv6 protocol (see~\cref{sec:1}). ICMPv6 is a new protocol, even if it shares some functionalities with ICMP. The similarities, both in functionality and in the naming conventions, may induce security practitioners to apply best practices used with ICMP, in the new ICMPv6 world. The transition period, where both IPv4 and IPv6 cohexist in network configurations, is another point of interest. This period may introduce new vulnerabilities, because IPv6 is already present and active by default in most OSs, but best practices related to the old protocol suite are no more applicable. New best practices must be researched, by taking into account the new requirements of the protocol and the changed context of networked communication. The context in wich ICMPv6 must operate is identified by the presence of more devices and a new philosophy related to the boundaries of networks, where concepts like Bring Your Own Device (BYOD) and wireless networks require new strategies in terms of defense of the perimeter.

In the mean time, also the threat landscape and the sophistication of malware has changed. We use the term Advanced Persistent Threat (APT) to identify a kind of adversary, often sponsored by state actors with remarkable amount of budget, able to produce highly sophisticated malware and with a long-term strategy to pursue their goals. This context requires also to change the mindset of researchers and security administrators, which should now consider not only the case where an attacker attempts to find a breach, from outside, in an organization's perimeter, but also the case that the adversary already has a foothold in the private network, and wants to exfiltrate sensible data.

The background analysis (see~\cref{sec:2}) started from the Request For Comments (RFC) because they represent the agreement of different stackholders upon the protocols. RFCs specify the protocols by describing the goals and the functionalities required, and by stating what must, should, or may be implemented by each OS in order to allow the interoperability between different implementations. Since this is not a binding process, implementations may differ in some points, which may introduce vulnerabilities inside the communication. This establishes the basis of the research, and the need to verify, among different implementations, the level of compliance of the OSs to the agreements specified by RFCs.

This research introduced then the concept of Covert Channel, which is the exploitation of an existent communication path to hide data inside a legitimate traffic. This scenario assumes that a malicious actor has already a foothold in the perimeter and want to exfiltrate data without authorization. Covert Channels, among others, have two properties of interest for this research. The first one is related to the syntax and semantics preservation, when a packet must traverse an active warden. From a firewall, or router, point of view, its ability to disrupt a Covert Channel depends on the level of knowledge of the protocol, or, in other words, on its ability to detect changes on the syntax and semantics of the header field used for the Covert Channel. The second property is related to the bandwidth of the field, which translates to the ability of the Covert Channel to stay undetected for longer periods: a lower bandwidth implies more packets to be transmitted for data exfiltration, with the possibility to arise suspicion on the network traffic.

The IPv6 Ready project provides a certification for IPv6 implementers, with the aim to promote IPv6 to the audience. The certification is based on tests specified after the RFCs for each involved protocol. The tests are organized in sections under the RFC number, which includes the two main RFCs in scope with this research, RFC 4443 and RFC 4861.

The reasearch introduced the experimentation with the scientific method as the methodology (see~\cref{sec:3}) that best fit with the goals of this research, the validation, or negation, of the two following hypothesis:
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item  \textit{It is possible to manipulate the ICMPv6 protocol to exfiltrate data without authorization from an internal network to the outside and traversing a border network device}
 \item \textit{It is possible to manipulate the ICMPv6 protocol in order to traverse a border network device and gain unauthorized access to an internal network}
\end{enumerate}

The two hypothesis includes the traversing of a border network device, the active warden, to which the defense of the perimeter has been demanded in the context of the end-to-end communication of IPv6.

The border network device represents a crucial point for this research. In the context of the first hypothesis, related to Covert Channel, its understanding of the protocol is critical in its ability to disrupt the exfiltration of data. In the context of the second hypothesis, it represents the first line of defense for the internal perimeter. In both cases, its configuration, which may be based on old best practices no more applicable in the IPv6 world, represents a central point for this research:
\begin{enumerate}[noitemsep,topsep=0pt,partopsep=0pt]
 \item awareness for researcher and administrators related to the need of new best practices
 \item awareness for manager for the choice of the technology and the needed expertise for configuration
 \item relevance of the device for the security of the network, in relationship with the design of the protocol in terms of security, and network flow direction
\end{enumerate}

The test set for each hypothesis is another critical point in the experimentation. While for the test set of the first hypothesis each field of the messages specified by the RFCs has been chosen, for the second hypothesis this research defined a test set based on the Processing Rule of the message type, for Error and Informational messages, and based on succeessful internal attacks to verify the behavior of messages specified by the Neighbor Discovery (ND) protocol.

The implementation (see~\cref{sec:4}) of the experiment is the consequence of the research, background and motivations. The network has been built to allow the experimentation of both hypothesis, each following a network flow direction.

Each device has been chosen to represent a specific choice. The attacking device is a Raspberry Pi with Kali Linux, a small device that could be hidden where a laptop may arise suspicion. The internal Linux Debian may be the choice for a server, while the Windows 7 represents a workstation used by employees. The Netfilter Open represents the transition period where IPv6 is active but no defense is configured. The ASA with Default configuration and with ICMP module are the choices of an organization with some budget, the first without expertise to configure it, the second with a limited amount of expertise. The Netfilter with Best Practices, instead, is the choice of a company with a low budget, but with the necessary awarenes to hire an expert to manage the configuration with best practices.

In order to validate, or negate, the hypothesis, this research produced a Proof of Concept (PoC). The main library used for the PoC is Scapy, which allows to build network packets for specific protocols, modify the fields, and also build new protocols. The library is a good example on the work that must be done for testing IPv6 and ICMPv6: the official implementation includes some bugs related to the IPv6 world, which have been solved inside the development version, which is the one used for the experimentation. The development version, as a side effect, includes new fields, for some ICMPv6 messages, which are defined by RFCs that are not yet approved by the community.

The experiment has been run (see~\cref{sec:5}) for both hypothesis. The results confirmed some expectations, while for some test, configurations, and network flow, the observations led to unexpected behaviors.

It is worth to remember that the validation of the hypothesis is given by the logical OR of the related experiments, performed against each warden configuration and target. The relevance of the results, instead, depends also on the number of tests that validated each hypothesis.

\subsection{First Hypothesis}

The first hypothesis (see~\cref{resultsFirstHypothesis}) has been validated by the experimentation. The relevance of the results, for this hypothesis, is very high.

The Netfilter Open configuration represents the trivial case, where a packet that reaches the warden is forwarded to its destination without further inspection. Since the firewall has no knowledge of the protocol, it is not able to detect possible changes on the syntax and semantics of the used field. 

This configuration allows to conclude that the ICMPv6 protocol allows the presence of Covert Channels for exfiltration operations, and that it must rely on other devices or services to detect and disrupt them.

The ASA with Default configuration showed a difference between expectations and actual results. Even though best practices suggest to never leave a device with the default configuration, the expectations after buying the ASA firewall is to have a device that, by default, follows the specifications of the RFCs and applies the best practices. This is not the case, as depicted by the table with the results (see~\cref{appendix:resultsFirst}). The Error message type are required for a correct communication between nodes, and are used by intermediate device, in the context of an end-to-end communication, to inform the sender that some packets have issues along the path to their destination. Those messages are blocked by this configuration, with the effect to block the Covert Channel, but also the communication of potential issues. Another unexpected result is related to the messages specified by the ND protocol, which are allowed to traverse the appliance despite their local-link scope nature.

The ASA with ICMP module presents similar results with respect to ist default configuration. The differences are represented by the Code field of the Echo Request message, and by the fields of the Echo Reply message. The expectations of this research was quite different, because of a wrong interpretation of the goals of the ICMP module, that is, the addition of deep packet inspection capabilities, with a more robust knowledge of the protocol and the consequent disruption of the Covert Channel. Instead, the ICMP module is used to add a session to the ICMPv6 protocol to allow the returning traffic, which is the case of an Echo Request that could generate an Echo Reply. The experiment shows that the module is able to detect the Covert Channel that uses the Code field of the Echo Request. The module inspected the traffic, and droped the packet with a \textit{inspect-icmp-bad-code} error. Covert Channels that used the other fields of the Echo Request, instead, were not detected because not inspected. In addition, the lack of a session allowed the appliance to disrupt the Covert Channels related to the Echo Reply fields.

The Netfilter with Best Practice configuration (see~\cref{appendix:netfilterBestAppendix}), which is a contribution of this research, fulfilled the expectations and allows for some more considerations. The hypothesis has been negated for the messages specified by the ND protocol, and validated by the other message types.

\textbf{Considerations}

It is useful at this point to step back and try to evaluate the protocol itself, by keeping away for a moment the last part of the hypothesis, the one that includes the border network device. The trivial case, the one with the Netfilter Open configuration, may represent this case, where the only device's task is to forward packets.

As shown before, this special case validates the hypothesis for all the messages and fields. This result leads to the following question:

\textit{the presence of covert channels in the ICMPv6 protocol is specific to the protocol itself, to the way it has been designed and implemented, or this presence could be extended to other networked protocols?}

It is the opinion of this research that this presence could be extended to other protocols, as far as the protocol has a mechanism that allows it to be transported to the destination. For ICMPv6, this mechanism is granted by the IPv6 protocol. On the other side, a trivial example is the destination address field of the IPv6 protocol: since the field is used to route the packet, a hypothetical covert channel that use this field will disrupt the communication, and the covert channel itself. Other protocols must be tested to confirm that they could be used for a covert channel, but if they rely on other protocols to be delivered, there is a great possibility that they are vulnerable as well, in all or some of their fields.

As the experiment shows, each field could be used for a covert channel. The nature of this particular configuration depicts the fact that the ICMPv6 protocol is vulnerable for this kind of misuse of a network protocol. The defense, in fact, is delegated to other device, like active warden, or protocols.

From an implementation point of view, the specification in RFCs do not explicitly mention the behavior of intermediate devices with respect to ICMPv6 packets. The specifications regard only end systems and the behavior of the sender and receiver of the packet. In the validation of the Neighbor Discovery protocol, the RFC specifies that a packet whose IPv6 Hop Limit field is less than 255 must be silently discarded \cite{rfc4861}. The directive refers to end systems, which could also be routers or firewalls, if the packet is originated from, or directed to it. Nevertheless, this directive may be an implicit suggestion for a defense mechanism on intermediate devices. 

From a design point of view, there are some consideration that are worth to underline. First, the presence of a covert channel is in the design of the protocol itself. The opinion of this research is that this is common and acceptable, because a network protocol must adhere to its requirements only, and any addition, in terms of functionality, could introduce complexity and new vulnerabilities. Other protocols must be designed and implemented to deal with other kind of functionalities. A simple example is the IPv6 protocol, which supplies the transport mechanism. In the case of ICMPv6, a security mechanism to filter manipulated packets is demanded to the active wardens with knowledge of the syntax and semantics of the protocol.

The second consideration is related to the unused and reserved fields. Even though their presence could be justified by the needs to maintain a consistency in the lenght of the header, or for future use, these kind of fields may be considered overdesign. As mentioned before, a covert channel must be consistent to the syntax and semantics of the field to stay undetected. By introducing such fields in the design, the ICMPv6 protocol defines fields semantically meaningless, which gives less weapons to detect the covert channel to those intermediate devices to which the security of ICMPv6 is delegated.

Another aspect that is worth to analyze is the behavior of the active wardens in relationship with covert channels. The Netfilter configuration with Best Practices represents a service that must be completely configured accordingly to the needs of an organization, which involves an analysis of the requirements, and an understanding of the security implications that a choice may produce. In this case, the persons involved in the process needs to be aware of what a specific configuration is able to do. The experiment shows that following the best practices is not enough to block all the covert channel, and this research suggested the use of other services. This is a contribution in terms of security awareness.

The configuration of the ASA firewall, instead, may introduce some issues, depending on the approach taken by the management and security personnel. The experiment shows some differences between the expectations of this research and the actual results. The configuration applied to the device by an organization may follow their expectations as well, with the consequence to be vulnerable to data exfiltration using a covert channel. The default policy of the ASA firewall allows traffic to travel from an interface with high security level to an interface with lower secuirty level, but not the opposite \footnote{\url{http://www.cisco.com/c/en/us/td/docs/security/asa/asa91/configuration/general/asa_91_general_config/interface_complete_routed.html}, accessed 22.10.2016}. This policy may be seen as an asymmetric evaluation between the risk that a malicious actor try to break the company's defenses from the outside network, and the risk that the same malicious actor has already gained access and try to exfiltrate data. Since one of the goal of this research is to produce the necessary awareness, this asymmetry must be taken into consideration.

\subsection{Second Hypothesis}

The hypothesis (see~\cref{resultsSecondHypothesis}) has been validated by the experimentation but its relevance is lower with respect to the first hypothesis. The reasons are represented by a limited number of successful tests (see~\cref{appendix:resultsSecond}) with a low impact on the target, and by a more robust ICMPv6 protocol in relationship of this network traffic flow.

The ICMPv6 Error messages negated the hypothesis, without exceptions. The messages included inside this category require to add the data related to the packet that generated the message as payload. The process, during a network communication, implies that a node, after reception of a packet that have some issue to reach its destination, drops the packet and send back the appropriate ICMPv6 message. The sending device, in the case of the experiment, has no ongoing communication because the data payload has been forged by the attacker. In the cases under testing, the ICMPv6 protocol is robust enough to understand that the requirements are not fulfilled, and the packet is droped.

The experiment with the Echo Request message validated the hypothesis for the Netfilter Open. As underlined during the presentation of the results, the target started the Reachability process, but a limitation on the number of entries in the Neighbor Cache, and its circular data structure, reduced the impact in a sensible way. Even if the hypothesis has been validated, the relevance is very low, because the target OSs developed the necessary countermeasures to deal with this kind of attacks.

The tests with the Echo Reply message validate the hypothesis for the Netfilter Open and, even if the impact is low, the relevance is high. As discussed during the presentation of the results, the tests sent an Echo Reply message to the Windows 7 target without the active host-based firewall. The experiment showed an unusual behavior of the target, which started to send Parameter Problem messages with Code 1 (Unrecognized next header type). The same test, against the Debian Linux target was not successful. Further investigations proved that the host-based firewall of Windows 7 target was blocking the generation of Parameter Problem messages with an erroneus IPv6 Next Header field.

The result allows to formulate the following statement, related to the Reconnaissance phase of an attack:

\textit{It is possible to identify a Windows 7 device, with SP1, with the host-based firewall turned off by sending an Echo Reply message and receiving back a Parameter Problem with Code 1}

In addition, the same test against a Windows 8.1 device as been successful, which allow to estend the vulnerability to another Windows device. The last statement suggests that other Windows devices may be vulnerable as well, and this must be further investigated in future works.

This research mentioned IPv6 Ready (see~\cref{subsub:ipv6Ready}), a project with the aim to test conformance and interoperability. The website \footnote{\url{https://www.ipv6ready.org/db/index.php/public/search/?vn=Microsoft&p=1&o=5&do=1&lim=50}, accessed on 24.11.2016} offers the possibility to search inside the approved list of the program for Microsoft products. The entry for the version of Windows used inside the experiment \footnote{\url{https://www.ipv6ready.org/db/index.php/public/logo/02-C-000524/}, accessed on 24.11.2016} shows that the project approved the product, which passed test specification 4.06 related to the Core Protocols. The project publishes the specifications of the tests \footnote{\url{https://www.ipv6ready.org/docs/Core_Conformance_Latest.pdf}, p. 290, accessed on 24.11.2016}, which includes the generation of a Parameter Problem message with Code 1 in case the Next Header is not recognized.

This research thinks that the host-based firewall, from a technical point of view, should not be considered as a component of an OS. Therefor the results of the test specified by the project may be considered correct. Nevertheless, the host-based firewall is active by default, and, in fact, modifies the behavior of the device. Which may be seen as a way to have the approval first, but then use other means to break the specification of the IETF and the interoperability with other devices in terms of network traffic.

Another aspect that is worth to underline is that the same tool used by system administrators to defend, administer, or monitor a network, may also be used by an attacker. This mindset, for example, leads Penetration Tester to emulate attackers and the thechniques they use in order to find the weeknesses of a system. Because of this, as a side effect of the experiment, this research tried to invert the process, that is, by imagine the methodology just found to enumerate the target in a defensive way. The script in~\cref{appendix:monitorSolution} shows the concept: while a thread receives packets and wait for a Parameter Problem,  the PoC sends the same packet of the experiment, with a two second interval. The context is given by an attacker that gained a foothold on the target device and needs to deactivate the firewall to perform some tasks. The administrator will start to receive Parameter Problem messages, with the results to be notified that, at least, there is a problem with the device.

This monitor solution may not be ideal because of the additional traffic generated. In spite of that, this research consider it a good example, in terms of awareness, about the interchangeability of the tools between attack and defense.

The results related to the ND protocol showed that the second hypothesis has been negated for all the messages. The ND protocol has a link-local scope and thus is used inside a local segment. The protocol specification have been enforced in the implementation of the OSs used as a target. The most important rule is related to the IPv6 Hop Limit field value, which must be 255. This rule alone is able to detect messages that have been forwarded by a routing capable device, which, for this research, have a Hop Limit value of 254. Other fields that enforce the scope of the ND protocol are the IPv6 Source and Destination Address, which for some messages must also have a link-local scope.

It is worth to note that the ND protocol, for what this research has been able to prove, relies on the fields of the IPv6 protocol to apply the defense mechanisms to negate the second hypothesis. In other words, this is a good example of collaboration between different protocols to provide a minimum level of security by design.

Finally, some consideration starting from the Netfilter with Best Practice configuration, which balances the requirements of the network communication with the needs in terms of security. Error and Informational messages are allowed to enter, with the exception of the Echo Request message type, while messages defined by the ND protocol, which are not supposed to be forwarded, are blocked. Nevertheless, test 55 (see~\cref{table:attackInternalResults6}) produced packets that were able to traverse the warden, to produce an effect on the end system, and to travel back to the source.

The last statement is very important for this research. This is because, from one side, it shows that, even following best practices, there is not the certainty to have a secure network. On the other side it shows that pursuing security through obscurity is a dangerous practice. The fact that an attacker is not aware that Windows 7 uses the host-based firewall to bypass the standards, does not grant that he or she will discover this information. But the lack of this knowledge may prevent a security administrator to perform the necessary tests and try to find solutions to mitigate possible risks.

\subsection{Firewall and Protocol Design Evaluation}
\label{sub:firewallEvaluation}

The design of the ICMPv6 protocol, in relationship to the network flow for the first hypothesis, is a topic of interest in this evaluation. In this case, it is useful to distinguish between two broad categories, Information and Error messages from one side, and ND protocol messages on the other. The former have an Internet scope, which means that it is more difficult to secure the messages by design, for example by defining rules to apply in the forwarding chain of intermediate devices. This solution would slow down the forwarding of packets, while the practices follow the opposite direction, which is to have intermediate device with fast forwarding. Also the IPv6 design follows this rule, by having a fixed-length header which requires less computational power to understand the boundaries of the IPv6 header. In the case of the ND protocol the argument is different, because the scope of the messages is link-local. The design of the protocol enforces some rules: the Hop Limit must be 255 and some source and destination addressess must have link-local scope to be accepted. Nevertheless, these rules are enforced inside end systems, following the end-to-end communication of IPv6. This means that a covert channel, in the case the receiver is positioned before the end-system device in the communication path, is not disrupted by such rules. This research has no solution for this issue, but the opinion is that more research on this topic, in the design phase of protocols, should take place, especially considering the trend to use ICMPv6 as a container for messages used by other protocols and processes.

The experiment related to the second hypothesis showed different results. The hypothesis has been validated for few messages and firewall configurations. The firewall configuration is less relevant, because even in the case where the manipulated packets arrive at destination, most of the attacks are not successful. The rules suggested by the RFC are enforced inside the target and, in most of the cases, are sufficient to avoid unwanted behaviors. This is true for both categories, Error and Informational messages, and ND protocol messages.

The design of the ICMPv6 protocol, in this case, took into consideration the security of end systems, by providing rules to process and validate packets. The nature of such rules is different between the two categories. Error and Informational messages rely mostly on the data of the payload, which is the packet that generated the ICMPv6 message: without a valid payload, that represents an ongoing communication between the target and the device that generated the message, there is not a match and packet is dropped. The design of the ND protocol, instead, introduced some rules related to its link-local scope, which are enforced inside the end-system. Rules like an unchanged Hop Limit (255) has been sufficient to negate the second hypothesis, even in the cases where the firewall rules allowed the packets to enter the network segment.

In general, it is worth to underline that more effort has been put into the security of end-systems, which reflects the trend to secure internal networks from attacks originated from the outside world. While APT is a relatively new phenomenon, security practitioners and protocol designer should take into consideration that an adversary may already have a foothold in an organization's network. The configuration of the active wardens that follows the best practices, and deep packet inspection services, represent the defense layer. But security, as in other domains, must be included inside the first steps of the development process, requirement and design, and take into account also the network traffic flow that originates from an inside network.

\subsection{Future Work}

This research used a scenario-based experimentation because of the opinion that it is not sufficient to test the ICMPv6 protocol implemented by end-systems, but it is necessary to insert the protocol in an environment closer to one used in production system. Because of the complexity of Internet, it is not feasible to perform the experiment in such an environment. Nevertheless future research should consider more firewall configurations, and consequently more scenarios. This is useful to analyse the protocol more in depth, and try to underline possible weaknesses implicit inside the design of the protocol, that needs a specific firewall configuration to defeat possible attacks. The new scenarios should also include more target OS types and version, in order to extend the discussion and to underline where the implementation differs from the specifications.





\pagebreak

%------------------------------REFERENCES-----------------------------------

\addcontentsline{toc}{section}{References}


\bibliographystyle{IEEEtran}
\bibliography{bibi.bib}


\pagebreak

%-----------------------------APPENDIX--------------------------------

\appendix

\section{Appendix - Cisco ASA Version}
\label{AppendixCiscoVer}

\vspace{-5pt}
\begin{lstlisting}[style=python,basicstyle=\ttfamily\scriptsize]
 Cisco Adaptive Security Appliance Software Version 9.1(5) 
Device Manager Version 7.5(2)

Compiled on Thu 27-Mar-14 09:36 by builders
System image file is "disk0:/asa915-k8.bin"
Config file at boot was "startup-config"

ASA-EXP up 5 hours 57 mins

Hardware:   ASA5505, 256 MB RAM, CPU Geode 500 MHz,
Internal ATA Compact Flash, 128MB
BIOS Flash M50FW080 @ 0xfff00000, 1024KB

Encryption hardware device : Cisco ASA-5505 on-board accelerator (revision 0x0)
                             Boot microcode        : CN1000-MC-BOOT-2.00 
                             SSL/IKE microcode     : CNLite-MC-SSLm-PLUS-2_05
                             IPSec microcode       : CNlite-MC-IPSECm-MAIN-2.09
                             Number of accelerators: 1

 0: Int: Internal-Data0/0    : address is 0021.a02e.8564, irq 11
 1: Ext: Ethernet0/0         : address is 0021.a02e.855c, irq 255
 2: Ext: Ethernet0/1         : address is 0021.a02e.855d, irq 255
 3: Ext: Ethernet0/2         : address is 0021.a02e.855e, irq 255
 4: Ext: Ethernet0/3         : address is 0021.a02e.855f, irq 255
 5: Ext: Ethernet0/4         : address is 0021.a02e.8560, irq 255
 6: Ext: Ethernet0/5         : address is 0021.a02e.8561, irq 255
 7: Ext: Ethernet0/6         : address is 0021.a02e.8562, irq 255
 8: Ext: Ethernet0/7         : address is 0021.a02e.8563, irq 255
 9: Int: Internal-Data0/1    : address is 0000.0003.0002, irq 255
10: Int: Not used            : irq 255
11: Int: Not used            : irq 255

Licensed features for this platform:
Maximum Physical Interfaces       : 8              perpetual
VLANs                             : 3              DMZ Restricted
Dual ISPs                         : Disabled       perpetual
VLAN Trunk Ports                  : 0              perpetual
Inside Hosts                      : 50             perpetual
Failover                          : Disabled       perpetual
Encryption-DES                    : Enabled        perpetual
Encryption-3DES-AES               : Enabled        perpetual
AnyConnect Premium Peers          : 25             perpetual
AnyConnect Essentials             : Disabled       perpetual
Other VPN Peers                   : 10             perpetual
Total VPN Peers                   : 25             perpetual
Shared License                    : Disabled       perpetual
AnyConnect for Mobile             : Disabled       perpetual
AnyConnect for Cisco VPN Phone    : Disabled       perpetual
Advanced Endpoint Assessment      : Disabled       perpetual
UC Phone Proxy Sessions           : 2              perpetual
Total UC Proxy Sessions           : 2              perpetual
Botnet Traffic Filter             : Disabled       perpetual
Intercompany Media Engine         : Disabled       perpetual
Cluster                           : Disabled       perpetual

This platform has a Base license.

Serial Number: JMX1247Z330
Running Permanent Activation Key: 0x4e25d64e 0xf8628255 0xb822197c 0x8714f8d8 0x0b31aba6 
Configuration register is 0x1
Configuration last modified by enable_15 at 11:55:20.129 UTC Sat Oct 22 2016
\end{lstlisting}


\section{Appendix - Test Set - First Hypothesis}
\label{Appendix 3}


\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{4.5cm}|L{3.5cm}|L{4.5cm}|L{3.5cm}|}
\hline
\rowcolor{lightblue}
Message&Field&Message&Field\\
\hline
Destination Unreachable&Code&Router Solicitation&Code\\
Destination Unreachable&Length&Router Solicitation&Reserved\\
\cline{3-4}
Destination Unreachable&Unused&Router Advertisement&Code\\ 
\cline{1-2}
Packet Too Big&Code&Router Advertisement&Cur Hop Limit\\
Packet Too Big&MTU&Router Advertisement&M\\
\cline{1-2}
Time Exceeded&Code&Router Advertisement&O\\
Time Exceeded&Length&Router Advertisement&H\\
Time Exceeded&Unused&Router Advertisement&Prf\\
\cline{1-2}
Parameter Problem&Code&Router Advertisement&P\\
Parameter Problem&Pointer&Router Advertisement&Reserved\\
\cline{1-2}
Echo Request&Code&Router Advertisement&Router Life Time\\
Echo Request&Identifier&Router Advertisement&Reachable Time\\
Echo Request&Sequence Number&Router Advertisement&Retrans Timer\\
\cline{3-4}
Echo Request&Data&Neighbor Solicitation&Code\\
\cline{1-2}
Echo Reply&Code&Neighbor Solicitation&Reserved\\
Echo Reply&Identifier&Neighbor Solicitation&Target Address\\
\cline{3-4}
Echo Reply&Sequence Number&Neighbor Advertisement&Code\\
Echo Reply&Data&Neighbor Advertisement&R\\
\cline{1-2}
&&Neighbor Advertisement&S\\
&&Neighbor Advertisement&O\\
&&Neighbor Advertisement&Reserved\\
&&Neighbor Advertisement&Target Address\\
\cline{3-4}
&&Redirect&Code\\
&&Redirect&Reserved\\
&&Redirect&Target Address\\
&&Redirect&Destination Address\\
\hline
\end{tabular}}
\caption{Data Exfiltration Test Set}
\label{table:exfiltrationTestSet}
\end{table}
\end{savenotes}

\newpage

\section{Appendix - Commands - Second Hypothesis}
\label{AppendixCommands}

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{0.8cm}|L{8.0cm}|L{0.8cm}|L{9.0cm}|}
\hline
\rowcolor{lightblue}
Test&Command&Test&Command\\
\hline
1&execDestUnreachAllWin&29&execTimeExceededHopLimitWin\\
2&execDestUnreachAllLinux&30&execTimeExceededHopLimitLinux\\
3&execDestUnreachNoRouteWin&31&execTimeExceededFragmentReassemblyWin\\
4&execDestUnreachNoRouteLinux&32&execTimeExceededFragmentReassemblyLinux\\
5&execDestUnreachComAdminProhibWin&33&execTimeExceededBadCodeWin\\
6&execDestUnreachComAdminProhibLinux&34&execTimeExceededBadCodeLinux\\
7&execDestUnreachBeyondScopeWin&35&execTimeExceededLengthWin\\
8&execDestUnreachBeyondScopeLinux&36&execTimeExceededLengthLinux\\ \cline{3-4}
9&execDestUnreachAdrUnreachWin&37&execParameterProblemErrHeaderWin\\
10&execDestUnreachAdrUnreachLinux&38&execParameterProblemErrHeaderLinux\\
11&execDestUnreachPortUnreachWin&39&execParameterProblemUnrecHeaderWin\\
12&execDestUnreachPortUnreachLinux&40&execParameterProblemUnrecHeaderLinux\\
13&execDestUnreachSrcFailedPolicyWin&41&execParameterProblemUnrecIPOptionWin\\
14&execDestUnreachSrcFailedPolicyLinux&42&execParameterProblemUnrecIPOptionLinux\\
15&execDestUnreachRejectRouteWin&43&execParameterProblemBadCodeWin\\
16&execDestUnreachRejectRouteLinux&44&execParameterProblemBadCodeLinux\\
17&execDestUnreachBadCodeWin&45&execParameterProblemFloodPointerWin\\
18&execDestUnreachBadCodeLinux&46&execParameterProblemFloodPointerLinux\\
19&execDestUnreachDifferentLengthWin&47&execParameterProblemFloodHighPointerWin\\
20&execDestUnreachDifferentLengthLinux&48&execParameterProblemFloodHighPointerLinux\\
\hline
21&execPacketTooBigMTUBigWin&49&execEchoRequestNeighCacheExhaustionDstVictimWin\\
22&execPacketTooBigMTUBigLinux&50&execEchoRequestNeighCacheExhaustionDstVictimLinux\\
23&execPacketTooBigMTUSmallWin&51&execEchoRequestNeighCacheExhaustionSrcVictimWin\\
24&execPacketTooBigMTUSmallLinux&52&execEchoRequestNeighCacheExhaustionSrcVictimLinux\\ \cline{3-4}
25&execPacketTooBigMTUWin&53&execEchoReplyRemoteWin\\
26&execPacketTooBigMTULinux&54&execEchoReplyRemoteLinux\\
27&execPacketTooBigBadCodeWin&55&execEchoReplyRemoteWin\\
28&execPacketTooBigBadCodeLinux&&\\
\hline
\end{tabular}}
\caption{PoC Commands - Second Hypothesis}
\label{table:commands2H}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{1.8cm}|L{8.0cm}|L{0.8cm}|L{8.0cm}|}
\hline
\rowcolor{lightblue}
Test&Command&Test&Command\\
\hline
56-61&execRAPrefixRemoteWin&70&execNSRemoteSelfSolLinux\\ \cline{3-4}
62-67&execRAPrefixRemoteLinux&71&execNACacheFloodingRemoteLinux\\
\hline
68&execRAMTURemoteWin&72&execRedirectRemoteWin\\
69&execRAMTURemoteLinux&73&execRedirectRemoteLinux\\
\hline
\end{tabular}}
\caption{PoC Commands - Second Hypothesis}
\label{table:commands2H2}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|L{8.0cm}|L{8.0cm}|}
\hline
\rowcolor{lightblue}
Command&Command\\
\hline
execRSInternalWin&execNSInternalFloodingWin\\
execRSInternalLinux&execNSInternalFloodingLinux\\
execRSInternalFirewall&execNSInternalSelfSolWin\\ \cline{1-1}
execRAPrefixInternalWin&execNSInternalSelfSolLinux\\ \cline{2-2}
execRAPrefixInternalLinux&execNACacheFloodingInternalWin\\ \cline{1-1}
execRAMTUInternalWin&execNACacheFloodingInternalLinux\\ \cline{2-2}
execRAMTUInternalLinux&execNAWinMitmInternal\\ \cline{2-2}
&execRedirectInternalWin\\
\hline
\end{tabular}}
\caption{PoC Commands - Internal Tests}
\label{table:commands2HInt}
\end{table}
\end{savenotes}

  
\clearpage
\newpage

\section{Appendix - Results}
\label{Appendix 4}
\vspace{-20pt}
\subsection{First Hypothesis}
\label{appendix:resultsFirst}


\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{5.0cm}|L{5.0cm}|C{2.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|}
\hline
\rowcolor{lightblue}
Test Number&Message&Field&Bandwidth (Bytes/Packet)&\multicolumn{4}{c|}{Firewall Configuration}\\ \cline{5-8}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4\\
\hline
1&Destination Unreachable&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
2&Destination Unreachable&Length&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
3&Destination Unreachable&Unused&3&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
\hline
4&Packet Too Big&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
5&Packet Too Big&MTU&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
\hline
6&Time Exceeded&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
7&Time Exceeded&Length&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
8&Time Exceeded&Unused&3&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
\hline
9&Parameter Problem&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
10&Parameter Problem&Pointer&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
\hline
11&Echo Request&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}\\
12&Echo Request&Identifier&2&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}\\
13&Echo Request&Sequence Number&2&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}\\
14&Echo Request&Data&8&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}\\
\hline
15&Echo Reply&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}\\
16&Echo Reply&Identifier&2&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}\\
17&Echo Reply&Sequence Number&2&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}\\
18&Echo Reply&Data&8&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
19&Router Solicitation&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
20&Router Solicitation&Reserved&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
21&Router Advertisement&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
22&Router Advertisement&Cur Hop Limit&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
23&Router Advertisement&M&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
24&Router Advertisement&O&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
25&Router Advertisement&H&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
26&Router Advertisement&Prf&0.25&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
27&Router Advertisement&P&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
28&Router Advertisement&Reserved&0.25&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
29&Router Advertisement&Router Life Time&2&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
30&Router Advertisement&Reachable Time&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
31&Router Advertisement&Retrans Timer&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
\end{tabular}}}
\caption{Data Exfiltration Results}
\label{table:exfiltrationResults1}
\end{table}
\end{savenotes}


\begin{savenotes}
\begin{table}[!htpb]
\centering
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\begin{tabular}{|C{1.0cm}|L{5.0cm}|L{5.0cm}|C{2.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|}
\hline
\rowcolor{lightblue}
Test Number&Message&Field&Bandwidth (Bytes/Packet)&\multicolumn{4}{c|}{Firewall Configuration}\\ \cline{5-8}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4\\
\hline
32&Neighbor Solicitation&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
33&Neighbor Solicitation&Reserved&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
34&Neighbor Solicitation&Target Address&16&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
35&Neighbor Advertisement&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
36&Neighbor Advertisement&R&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
37&Neighbor Advertisement&S&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
38&Neighbor Advertisement&O&0.12&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
39&Neighbor Advertisement&Reserved&3&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
40&Neighbor Advertisement&Target Address&16&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
41&Redirect&Code&1&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
42&Redirect&Reserved&4&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
43&Redirect&Target Address&16&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
44&Redirect&Destination Address&16&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}\\
\hline
\end{tabular}}
\caption{Data Exfiltration Results}
\label{table:exfiltrationResults2}
\end{table}
\end{savenotes}

\clearpage

\subsection{Second Hypothesis}
\label{appendix:resultsSecond}


\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
1&Testing general behavior by sending all codes in sequence&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No reactions from target, using Wireshark on firewall's eth0\\
2&Testing general behavior by sending all codes in sequence&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No reactions from target, using Wireshark on firewall's eth0\\
\hline
3&Code 0, Src is Attacker, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
4&Code 0, Src is Attacker, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
\hline
5&Code 1, Src is Firewall, TCP payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
6&Code 1, Src is Firewall, TCP payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
\hline
7&Code 2, Src is Firewall, TCP payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
8&Code 2, Src is Firewall, TCP payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
\hline
9&Code 3, Src is Attacker, TCP payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
10&Code 3, Src is Attacker, TCP payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
\hline
11&Code 4, Src is Attacker, TCP payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
12&Code 4, Src is Attacker, TCP payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
\hline
13&Code 5, Src is Firewall, TCP payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
14&Code 5, Src is Firewall, TCP payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http)\\
\hline
15&Code 6, Src if Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
16&Code 6, Src if Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No effects on conversation (http and echo request)\\
\hline
17&Testing unknown codes (7 to 255)&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&Packets dropped at destination\\
18&Testing unknown codes (7 to 255)&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&Packets dropped at destination\\
\hline
19&Testing Length field (0 to 255)&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&\\
20&Testing Length field (0 to 255)&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Destination Unreachable (Type 1)}
\label{table:attackInternalResults1}
\end{table}
\end{savenotes}



\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
21&MTU is 2000, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
22&MTU is 2000, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
\hline
23&MTU is 500, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
24&MTU is 500, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
\hline
25&MTU is 1300, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
26&MTU is 1300, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
\hline
27&Unknown codes (1-255), Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
28&Unknown codes (1-255), Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of changes\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Packet Too Big (Type 2)}
\label{table:attackInternalResults2}
\end{table}
\end{savenotes}


\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
29&Code 0, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
30&Code 0, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
31&Code 1, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
32&Code 1, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
33&Unknown codes (2-255), Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
34&Unknown codes (2-255), Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
35&Testing Length field (0 to 255)&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&\\
36&Testing Length field (0 to 255)&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Time Exceeded (Type 3)}
\label{table:attackInternalResults3}
\end{table}
\end{savenotes}



\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark and OS specific commands)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
37&Code 0, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
38&Code 0, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
39&Code 1, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
40&Code 1, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
41&Code 2, Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
42&Code 2, Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
43&Unknown codes (4-255), Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
44&Unknown codes (4-255), Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
45&Flooding pointer values (0-1024), Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No changes in end device, possible measurement and comparisons using Task Manager\\
46&Flooding pointer values (0-1024), Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No changes in end device, possible measurement and comparisons using command top\\
\hline
47&Flooding pointer values (3024000000-3024001000), Src is Firewall, Echo Request payload&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No changes in end device, possible measurement and comparisons using Task Manager\\
48&Flooding pointer values (3024000000,3024001000), Src is Firewall, Echo Request payload&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No changes in end device, possible measurement and comparisons using command top\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Parameter Problem (Type 4)}
\label{table:attackInternalResults4}
\end{table}
\end{savenotes}




\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
49&Neighbor Cache Exhaustion, Src is spoofed prefix /64 plus 16 bits range, Dst is Victim&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Both victim and linux firewall affected\\
50&Neighbor Cache Exhaustion, Src is spoofed prefix /64 plus 16 bits range, Dst is Victim&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Both victim and linux firewall affected\\
\hline
51&Neighbor Cache Exhaustion, Src is Victim, Dst is spoofed prefix /64 plus 16 bits range&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Both victim and linux firewall affected\\
52&Neighbor Cache Exhaustion, Src is Victim, Dst is spoofed prefix /64 plus 16 bits range&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Only linux firewall affected\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Echo Request (Type 128)}
\label{table:attackInternalResults5}
\end{table}
\end{savenotes}


\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
53&Src is Attacker, packet sent without request&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
54&Src is Attacker, packet sent without request&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&No evidence of effects\\
\hline
55&Src is Attacker, Victim firewall disabled&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{ok}&Windows end system start to send ICMPv6 Parameter Problem with code 1 to Src\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Echo Reply (Type 129)}
\label{table:attackInternalResults6}
\end{table}
\end{savenotes}


\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Selected&\multicolumn{1}{C{6.0cm}|}{Internal Attack Description}&Tgt. OS&\multicolumn{5}{c|}{Results}\\
\hline
\includegraphics[width=4mm, height=4mm]{notok}&Flood Victim with NS&Win&\multicolumn{5}{L{11.0cm}|}{The test failed, the target host drops the packets without generating new processes or messages}\\
\includegraphics[width=4mm, height=4mm]{notok}&Flood Victim with NS&Linux&\multicolumn{5}{L{11.0cm}|}{The test failed, the target host drops the packets without generating new processes or messages}\\
\includegraphics[width=4mm, height=4mm]{notok}&Flood Victim with NS, Dst is all router multicast&Firewall&\multicolumn{5}{L{11.0cm}|}{Victim starts reachability process, test not selected because of Dst}\\
\hline

\end{tabular}}}
\caption{Attacking internal network, Router Solicitation (Type 133)}
\label{table:attackInternalResults7}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Selected&\multicolumn{1}{C{6.0cm}|}{Internal Attack Description}&Tgt. OS&\multicolumn{5}{c|}{Results}\\
\hline
\includegraphics[width=4mm, height=4mm]{ok}&Inject arbitrary prefix address, Src is Firewall Link-local&Win&\multicolumn{5}{L{11.0cm}|}{The prefix is successfully addedd and new address generated}\\
\includegraphics[width=4mm, height=4mm]{ok}&Inject arbitrary prefix address, Src is Firewall Link-local&Linux&\multicolumn{5}{L{11.0cm}|}{The prefix is successfully addedd and new address generated}\\
\hline
\includegraphics[width=4mm, height=4mm]{ok}&Inject MTU value, Src is Firewall Link-local&Win&\multicolumn{5}{L{11.0cm}|}{The MTU changed to 1350}\\
\includegraphics[width=4mm, height=4mm]{ok}&Inject MTU value, Src is Firewall Link-local&Linux&\multicolumn{5}{L{11.0cm}|}{The MTU changed to 1350}\\
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
56&Remote implementation of arbitrary prefix injection, Src is Firewall&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
57&Remote implementation of arbitrary prefix injection, Src is Debian Linux&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
58&Remote implementation of arbitrary prefix injection, Src is Windows 7&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
59&Remote implementation of arbitrary prefix injection, Src is Firewall, L is 0&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
60&Remote implementation of arbitrary prefix injection, Src is Firewall, R is 0&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
61&Remote implementation of arbitrary prefix injection, Src is Firewall, L and R are 0&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
\hline
62&Remote implementation of arbitrary prefix injection, Src is Firewall&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
63&Remote implementation of arbitrary prefix injection, Src is Debian Linux&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
64&Remote implementation of arbitrary prefix injection, Src is Windows 7&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
65&Remote implementation of arbitrary prefix injection, Src is Firewall, L is 0&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Router Advertisement (Type 134)}
\label{table:attackInternalResults8}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
66&Remote implementation of arbitrary prefix injection, Src is Firewall, R is 0&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
67&Remote implementation of arbitrary prefix injection, Src is Firewall, L and R are 0&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
\hline
68&Remote implementation of MTU injection, Src is equal to Dst&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
\hline
69&Remote implementation of MTU injection, Src is equal to Dst&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Router Advertisement (Type 134)}
\label{table:attackInternalResults9}
\end{table}
\end{savenotes}

\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Selected&\multicolumn{1}{C{6.0cm}|}{Internal Attack Description}&Tgt. OS&\multicolumn{5}{c|}{Results}\\
\hline
\includegraphics[width=4mm, height=4mm]{notok}&The aim of this attack is to flood the target with NS, using spoofed src address&Win Linux&\multicolumn{5}{L{11.0cm}|}{The test failed, the target hosts drop the packets without generating new processes or messages}\\
\hline
\includegraphics[width=4mm, height=4mm]{notok}&Attacker sends NS with Src MAC and Dst Solicited Multicast both of the target, the option Src link layer is the firewall&Win&\multicolumn{5}{L{11.0cm}|}{Packets are ignored by the receiver}\\
\includegraphics[width=4mm, height=4mm]{ok}&Attacker sends NS with Src MAC and Solicited Multicast both of the target, the option Src link layer is the firewall&Linux&\multicolumn{5}{L{11.0cm}|}{Packets arrive at Dst and the device start to send NA to itself}\\
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
70&Src MAC is Firewall, Dst and Src IPv6 is the Target&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Packets arrive but droped, Hop Limit < 255\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Neighbor Solicitation (Type 135)}
\label{table:attackInternalResults10}
\end{table}
\end{savenotes}



\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Selected&\multicolumn{1}{C{6.0cm}|}{Internal Attack Description}&Tgt. OS&\multicolumn{5}{c|}{Results}\\
\hline
\includegraphics[width=4mm, height=4mm]{notok}&Internal Neighbor Cache flooding with Solicited and Override flags&Win&\multicolumn{5}{L{11.0cm}|}{Failed, ignored by victim}\\
\includegraphics[width=4mm, height=4mm]{ok}&Internal Neighbor Cache flooding with Solicited and Override flags&Linux&\multicolumn{5}{L{11.0cm}|}{Test is successful, Neigh Cache overridden}\\
\hline
\includegraphics[width=4mm, height=4mm]{notok}&Mitm attack using Debian Linux as attacker. NA to Target, NAs to Firewall with both Win temporary and permanent IPv6&Win&\multicolumn{5}{L{11.0cm}|}{Test is successful, from attacker (Debian Linux Internal) is possible to intercept traffic from/to the target. Test not selected, Win temporary not disclosed to external network}\\
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
71&Remote implementation of internal cache flooding, Src is spoofed IPv6, Dst is Target&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Echo Request arrives at Dst, Target start sending NS, but the arrived NA is droped, Hop Limit is <255\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Neighbor Advertisement (Type 136)}
\label{table:attackInternalResults11}
\end{table}
\end{savenotes}




\begin{savenotes}
\begin{table}[!h]
\addtolength{\tabcolsep}{1pt}
\noindent\makebox[\textwidth]{
\addvbuffer[-15pt 0pt]{\begin{tabular}{|C{1.0cm}|L{6.0cm}|C{1.5cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|C{1.0cm}|L{7.0cm}|}
\hline
\rowcolor{lightblue}
Selected&\multicolumn{1}{C{6.0cm}|}{Internal Attack Description}&Tgt. OS&\multicolumn{5}{c|}{Results}\\
\hline
\includegraphics[width=4mm, height=4mm]{ok}&Half Mitm attack using Debian Linux as attacker. Redirect to victim&Win&\multicolumn{5}{L{11.0cm}|}{Target is blocking Redirect by default. Without host firewall attack successful, half of the traffic is intercepted}\\
\hline
\rowcolor{lightblue}
Test&\multicolumn{1}{C{6.0cm}|}{Description}&Tgt. OS&\multicolumn{4}{c|}{Firewall Configuration}&Target behavior when packets reach destination (observed using Wireshark)\\ \cline{4-7}
\rowcolor{lightblue}
\multirow{-2}{*}{}&\multirow{-2}{*}{}&\multirow{-2}{*}{}&1&2&3&4&\multirow{-2}{*}{}\\
\hline
72&Remote implementation of internal half Mitm, Src is spoofed Firewall, Dst is Victim, Redirect Target is Attacker and Redirect Dst is External Adr&Win&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails, with and without active host firewall: Hop Limit < 255, Src is not Link-local, Win start conversation with tmp address. Note: for ASA tests, packets blocked, but for experiment not possible to use other external host\\
\hline
73&Remote implementation of internal half Mitm, Src is spoofed Firewall, Dst is Victim, Redirect Target is Attacker and Redirect Dst is External Adr&Linux&\includegraphics[width=4mm, height=4mm]{ok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&\includegraphics[width=4mm, height=4mm]{notok}&Test fails: Hop Limit < 255, Src is not Link-local. Note: for ASA tests, packets blocked, but for experiment not possible to use other external host\\
\hline
\end{tabular}}}
\caption{Attacking internal network, Redirect (Type 137)}
\label{table:attackInternalResults12}
\end{table}
\end{savenotes}

\clearpage

\pagebreak

\section{Appendix - Firewall Configurations}
\label{Appendix 5}

\subsection{Netfilter Open Configuration}
\label{appendix:netfilterOpenApp}

\lstinputlisting[style=bash,caption=Netfilter open,label=NetfilterOpenConfig]{files/firewall_open_rules.sh}

\subsection{ASA Default Configuration}
\label{appendix:ASAdefaultAppendix}

\lstinputlisting[style=bash,caption=ASA Default,label=ASADefaultConfig]{files/ASADefaultConfig}


\subsection{ASA Default with ICMP Module Configuration}
\label{appendix:ASAicmpAppendix}


\lstinputlisting[style=bash,caption=ASA with ICMP module enabled,label=ASADefaultPlusICMPConfig]{files/ASADefaultPlusICMPConfig}

\subsection{Netfilter with Best Practices Configuration}
\label{appendix:netfilterBestAppendix}

\lstinputlisting[style=bash,caption=Netfilter with Best Practices,label=NetfilterBestPracticesConfig]{files/firewall_rules.sh}

\section{Appendix - Monitor Windows Firewall - PoC}
\label{appendix:monitorSolution}

\lstinputlisting[style=bash,caption=Monitor Windows Firewall - PoC,label=monitorSolutionPy]{files/monitorWinFirewall.py}

\end{document}
